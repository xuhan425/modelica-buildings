const char source_str1[] =
"#ifndef REAL\n"
"#define REAL float\n"
"#define ifDouble 0/*index to show it is double*/\n"
"#endif\n"
"\n"
"#define IX(i,j,k) ((i)+(IMAX)*(j)+(IJMAX)*(k))\n"
"#define FOR_EACH_CELL for(i=1; i<=imax; i++) { for(j=1; j<=jmax; j++) { for(k=1; k<=kmax; k++) {\n"
"#define FOR_ALL_CELL for(k=0; k<=kmax+1; k++) { for(j=0; j<=jmax+1; j++) { for(i=0; i<=imax+1; i++) {\n"
"#define FOR_ALL_CELL_IJK for(i=0; i<=imax+1; i++) { for(j=0; j<=jmax+1; j++) { for(k=0; k<=kmax+1; k++) {\n"
"#define FOR_U_CELL for(k=1; k<=kmax; k++) { for(j=1; j<=jmax; j++) { for(i=1; i<=imax-1; i++) {\n"
"#define FOR_V_CELL for(i=1; i<=imax; i++) { for(j=1; j<=jmax-1; j++) { for(k=1; k<=kmax; k++) {\n"
"#define FOR_W_CELL for(i=1; i<=imax; i++) { for(j=1; j<=jmax; j++) { for(k=1; k<=kmax-1; k++) {\n"
"\n"
"#define FOR_KI for(i=1; i<=imax; i++) { for(k=1; k<=kmax; k++) {{\n"
"#define FOR_IJ for(i=1; i<=imax; i++) { for(j=1; j<=jmax; j++) {{\n"
"#define FOR_JK for(j=1; j<=jmax; j++) { for(k=1; k<=kmax; k++) {{\n"
"#define END_FOR }}}\n"
"\n"
"#define SMALL 0.00001\n"
"#define SUCCESS 0\n"
"#define FAILURE 1\n"
"#define MAX_SOURCE_SIZE (0x100000)\n"
"\n"
"#ifndef max\n"
"  #define max( a, b ) ( ((a) > (b)) ? (a) : (b) )\n"
"#endif\n"
"\n"
"#ifndef sign\n"
"  #define sign(x) ( (x > 0) - (x < 0) )\n"
"#endif\n"
"\n"
"#define PI 3.1415926\n"
"\n"
"#define RACK_MONITOR_POINTS 4\n"
"\n"
"#define X     0\n"
"#define Y     1\n"
"#define Z     2\n"
"#define VX    3\n"
"#define VY    4\n"
"#define VZ    5\n"
"#define VXM   6\n"
"#define VYM   7\n"
"#define VZM   8\n"
"#define VXS   9\n"
"#define VYS   10\n"
"#define VZS   11\n"
"#define IP    12\n"
"#define QFLUXBC 13 // Heat flux on the boundary\n"
"#define QFLUX 14  // Heat flux\n"
"#define TMP1  15\n"
"#define TMP2  16\n"
"#define TMP3  17\n"
"#define TEMP  18\n"
"#define TEMPS 19\n"
"#define TEMPM 20\n"
"#define AP    21\n"
"#define AN    22\n"
"#define AS    23\n"
"#define AW    24\n"
"#define AE    25\n"
"#define AF    26\n"
"#define AB    27\n"
"#define  B    28\n"
"#define GX    29\n"
"#define GY    30\n"
"#define GZ    31\n"
"#define AP0   32\n"
"#define PP    33\n"
"#define FLAGP 34\n"
"#define FLAGU 35\n"
"#define FLAGV 36\n"
"#define FLAGW 37\n"
"#define LOCMIN 38\n"
"#define LOCMAX 39\n"
"#define VXBC 40\n"
"#define VYBC 41\n"
"#define VZBC 42\n"
"#define TEMPBC 43\n"
"#define Xi1 44\n"
"#define Xi2 45\n"
"#define Xi1S 46\n"
"#define Xi2S 47\n"
"#define Xi1BC 48\n"
"#define Xi2BC 49\n"
"#define C1  50\n"
"#define C2  51\n"
"#define C1S 52\n"
"#define C2S 53\n"
"#define C1BC 54\n"
"#define TMP4 55\n"
"#define MIN_DISTANCE 56 // the minimal distance to the boundaries, using in zero equation model\n"
"#define TILE_OPEN_BC 57 // the opening ratio of the tiles\n"
"#define TILE_RESI_BC 58 // the corresponding resistance ratio of the opening ratio for the tiles\n"
"#define TILE_FLOW_BC 59 // the velocity at each tile\n"
"#define PBC 60 // the pressure boundary condition for outlets/tiles\n"
"#define IPS 61 // the pressure source associated with the tile when simulating the room and plenum together\n"
"#define APXS 62 // Source for AP VX\n"
"#define APYS 63 // Source for AP VY\n"
"#define APZS 64 // Source for AP VZ\n"
"#define RESX 65 // Resistance in X, i.e., tile, plastic curtain, etc.\n"
"#define RESY 66 // Resistance source in Y, i.e., tile, plastic curtain, etc.\n"
"#define RESZ 67 // Resistance source in Z, i.e., tile, plastic curtain, etc.\n"
"#define C2BC 68  // Last variable\n"
"\n"
"typedef enum{NOSLIP, SLIP, INFLOW, OUTFLOW, PERIODIC, SYMMETRY} BCTYPE;\n"
"\n"
"#define SOLID 1\n"
"#define INLET 0\n"
"#define OUTLET 2\n"
"#define TILE 3\n"
"#define RACK_INLET 4\n"
"#define RACK_OUTLET 5\n"
"#define FLUID -1\n"
"\n"
"#define RACK 100\n"
"\n"
"typedef enum{TCONST, QCONST, ADIBATIC} BCTTYPE;\n"
"\n"
"typedef enum{GS, TDMA, JACOBI} SOLVERTYPE;\n"
"\n"
"typedef enum{SEMI, LAX, UPWIND, UPWIND_NEW, CENTRAL} ADVECTION;\n"
"\n"
"typedef enum{LAM, CHEN, CONSTANT} TUR_MODEL;\n"
"\n"
"typedef enum{BILINEAR, FSJ, HYBRID} INTERPOLATION;\n"
"\n"
"typedef enum{DEMO, DEBUG, RUN} VERSION;\n"
"\n"
"typedef enum{FFD, SCI, TECPLOT} FILE_FORMAT;\n"
"\n"
"typedef enum{FFD_WARNING, FFD_ERROR, FFD_NORMAL, FFD_NEW} FFD_MSG_TYPE;\n"
"\n"
"typedef enum{XY, YZ, ZX} PLANETYPE;\n"
"\n"
"typedef enum {ADV, DIF, PRO} FFD_TERM;\n"
"\n"
"typedef enum {AIRFLOW_BASE, PRESSURE_BASE, HYBRID_BASE, NS_SOURCE, NO_EXIST} TILE_FLOW_CORRECTION;\n"
"\n"
"typedef enum {PRESCRIBED_VALUE, ZERO_GRADIENT} BC_TYPE;\n"
"\n"
"// Parameter for geometry and mesh\n"
"typedef struct {\n"
"  REAL  Lx; // Domain size in x-direction (meter)\n"
"  REAL  Ly; // Domain size in y-direction (meter)\n"
"  REAL  Lz; // Domain size in z-direction (meter)\n"
"  int   imax; // Number of interior cells in x-direction\n"
"  int   jmax; // Number of interior cells in y-direction\n"
"  int   kmax; // Number of interior cells in z-direction\n"
"  int   index; // Total number of boundary cells\n"
"  int   pindex; // Index in plane\n"
"  PLANETYPE   plane; // plane selection\n"
"  REAL  dx; // Length delta_x of one cell in x-direction for uniform grid only\n"
"  REAL  dy; // Length delta_y of one cell in y-direction for uniform grid only\n"
"  REAL  dz; // Length delta_z of one cell in z-direction for uniform grid only\n"
"  REAL  volFlu; // Total volume of fluid cells\n"
"  int   uniform; // Only for generating grid by FFD. 1: uniform grid; 0: non-uniform grid\n"
"  int tile_putX; // tile is put in X direction\n"
"  int tile_putY; // tile is put in Y direction\n"
"  int tile_putZ; // tile is put in Z direction\n"
"} GEOM_DATA;\n"
"\n"
"// Parameter for the data output control\n"
"typedef struct{\n"
"  int cal_mean; // 1: Calculate mean value; 0: False\n"
"  REAL v_max; // Maximum velocity for visualizations (Reference)\n"
"  REAL v_ref; // Reference velocity for visualization\n"
"  REAL Temp_ref; // Reference temperature for visualizations\n"
"  REAL v_length; // Change of velocity vector length in demo window\n"
"  REAL Tmax; // Maximum temperature for visualizations (Reference)\n"
"  REAL Tmin; // Minimum temperature for visualizations (Reference)\n"
"  int i_N; // Number of grids plotted in x direction\n"
"  int j_N; // Number of grids plotted in y direction\n"
"  int k_N; // Number of grids plotted in z direction\n"
"  int winx; // Resolution of screen at x direction in pixel\n"
"  int winy; // Resolution of screen at y direction in pixel\n"
"  int winz; // Resolution of screen at x direction in pixel\n"
"  int omx; // Internal\n"
"  int omy; // Internal\n"
"  int mx; // Internal\n"
"  int my; // Internal\n"
"  int win_id; // Internal: Windows id\n"
"  int mouse_down[3]; // Internal: Record for mouse action\n"
"  VERSION version; // DEMO, DEBUG, RUN\n"
"  int screen; // Screen for display: 1 velocity; 2: temperature; 3: contaminant\n"
"  int tstep_display; // Number of time steps to update the visualization\n"
"  int mouse_i; // mouse click located i\n"
"  int mouse_j; //mouse click located j\n"
"  int mouse_k; // mouse click located k\n"
"} OUTP_DATA;\n"
"typedef struct{\n"
"  int cal_mean; // 1: Calculate mean value; 0: False\n"
"  VERSION version; // DEMO, DEBUG, RUN\n"
"} OUTP_DATA_SIMP;\n"
"\n"
"typedef struct{\n"
"  FILE_FORMAT parameter_file_format; // Format of extra parameter file\n"
"  char parameter_file_name[100]; // Name of extra parameter file\n"
"  char block_file_name[100]; // Name of file stores block information\n"
"  int read_old_ffd_file; // 1: Read previous FFD file; 0: False\n"
"  char old_ffd_file_name[100]; // Name of previous FFD simulation data file\n"
"} INPU_DATA;\n"
"\n"
"typedef struct{\n"
"  REAL  nu; // Kinematic viscosity\n"
"  REAL  rho; // Density\n"
"  REAL  diff; // Diffusivity for contaminants\n"
"  REAL  alpha; // Thermal diffusivity\n"
"  REAL  coeff_h; // Convective heat transfer coefficient near the wall\n"
"  REAL  gravx; // Gravity in x direction\n"
"  REAL  gravy; // Gravity in y direction\n"
"  REAL  gravz; // Gravity in z direction\n"
"  REAL  beta; // Thermal expansion coefficient\n"
"  REAL cond; // Conductivity\n"
"  //REAL trefmax; // T Reference max defined by SCI\n"
"  REAL Cp; // Specific heat capacity\n"
"  REAL force; // Force to be added in demo window for velocity when left-click on mouse\n"
"  REAL heat; // Heat to be added in demo window for contaminants when click middle button on mouse\n"
"  REAL source; // Source to be added in demo window for contaminants when right click on mouse\n"
"  int movie; // Output data for making animation (1:yes, 0:no)\n"
"  int output;   // Internal: 0: have not been written; 1: done\n"
"  TUR_MODEL tur_model; // LAM, CHEN, CONSTANT\n"
"  REAL chen_a; // Coefficient of Chen's zero equation turbulence model\n"
"  REAL Prt; // Turbulent Prandtl number\n"
"  REAL Temp_Buoyancy; // Reference temperature for calculating buoyancy force\n"
"  REAL Tem_Ave_LastTime; // Record average fluid temeprature in last time\n"
"  REAL Energy_Imb_Adv; // Energy imbalance after advection, W\n"
"  REAL coef_CONSTANT; // Constant for constant turbulence models\n"
"  REAL coef_stanchion; // the stanchion model coefficient\n"
"}PROB_DATA;\n"
"\n"
"typedef struct {\n"
"  int nb_inlet; // Number of inlet boundaries, provided by SCI\n"
"  int nb_outlet; // Number of outlet boundaries, provided by SCI\n"
"  int nb_block; // Number of internal block boundaries, provided by SCI\n"
"  int nb_wall; // Number of wall boundaries, provided by SCI\n"
"  int nb_source; // Number of sources, provided by SCI\n"
"  int nb_bc; // Number of boundaries, provided by SCI\n"
"  int nb_ConExtWin; // Number of exterior construction with windows\n"
"  int nb_port; // nPort = nInlet + nOutlet\n"
"  int nb_Xi; // Number of species\n"
"  int nb_C; // Number of substances\n"
"  int sha; // 1: have shade ; 0: no shade\n"
"  char **wallName; // *wallName[nb_wall]: Name of solid boundary (Wall, Window)\n"
"  char **inletName; // *inletName[nb_inlet]: Name of inlet boundary\n"
"  char **outletName; // *inletName[nb_outlet]: Name of outlet boundary\n"
"  char **portName; // *portName[nb_port]: Name of ports\n"
"  char **blockName; // *blockName[nb_block]: Name of internal block\n"
"  char **sourceName; // *sourceName[nb_source]: Name of the source\n"
"  char **rackName; // *rackNmae[nb_rack]: name of rack\n"
"  int *wallId; // wallId[nb_wall]: Modelica wall boundary ID\n"
"  //int *inletId; // Modelica inlet boundary ID\n"
"  int *portId; // portId[nb_port]: Modelica outlet boundary ID\n"
"  REAL *AWall; // AWall[nb_wall]: Area of the surfaces\n"
"  REAL *APort; // APort[nb_port]: Area of the outlets\n"
"  REAL *temHea; // temHea[nb_wall]: Value of thermal conditions at solid surface\n"
"  REAL *temHeaAve; // temHeaAve[nb_wall]: Surface averaged value of temHea\n"
"  REAL *temHeaMean; // temHeaMean[nb_wall]: Time averaged value of temHeaAve\n"
"  REAL *velPort; // velPort[nb_port]: Velocity of air into the room\n"
"                      // positive: into the room; negative out of the room\n"
"  REAL *QPort; // mass flowrate of the port\n"
"  REAL *velPortAve; // velPortAve[nb_port]: Surface averaged value of velPort\n"
"  REAL *velPortMean; // velPortMean[nb_port]: Time averaged value of velPortAve\n"
"  REAL *TPort; // TPort[nb_port] Air temperatures that the medium has if it were flowing into the room\n"
"  REAL *TPortAve; // TPortAve[nb_port] Surface averaged value of TPort\n"
"  REAL *TPortMean; // TPortMean[nb_port] Time averaged value of TPortAve\n"
"  REAL **XiPort; // XiPor[nb_port][nb_Xi]: species concentration of inflowing medium\n"
"  REAL **XiPortAve; // XiPortAve[nb_port][nb_Xi]: Surface averaged value of XiPort\n"
"  REAL **XiPortMean; // XiPortAve[nb_port][nb_Xi]: Time averaged value of XiPortAve\n"
"  REAL **CPort; // CPor[nb_port][nb_C]: the trace substances of the inflowing medium\n"
"  REAL **CPortAve; // CPortAve[nb_port][nb_C]: Surface averaged value of CPort\n"
"  REAL **CPortMean; // CPortMean[nb_port][nb_C]: Time averaged value of CPort\n"
"  int nb_rack; // number of rack in the data center room\n"
"  int **RackMap; // Map the inlet and outlet cell of rack, a N by 3 array, where N is number of racks\n"
"  REAL *RackFlowRate; // The volumetric flow rate for each rack in M3/s, a vector of N elements\n"
"  int *RackDir; // The cooling air flow direction of the rack, +1: X, -1: Y, +2: Y, -2: -Y, +3: Z, -3: -Z\n"
"  REAL *HeatDiss; // Heat dissipation of rack in W, a vector of N element\n"
"  REAL *RackArea; // Inlet or outlet area of rack, a vector of N element\n"
"  BC_TYPE outlet_bc; // type of outlet bc\n"
"}BC_DATA;\n"
"\n"
"typedef struct {\n"
"  int nb_inlet; // Number of inlet boundaries, provided by SCI\n"
"  int nb_outlet; // Number of outlet boundaries, provided by SCI\n"
"  int nb_block; // Number of internal block boundaries, provided by SCI\n"
"  int nb_wall; // Number of wall boundaries, provided by SCI\n"
"  int nb_source; // Number of sources, provided by SCI\n"
"  int nb_bc; // Number of boundaries, provided by SCI\n"
"  int nb_ConExtWin; // Number of exterior construction with windows\n"
"  int nb_port; // nPort = nInlet + nOutlet\n"
"  int nb_Xi; // Number of species\n"
"  int nb_C; // Number of substances\n"
"  int sha; // 1: have shade ; 0: no shade\n"
"  REAL mass_in;\n"
"  REAL mass_out;\n"
"  REAL mass_corr;\n"
"  BC_TYPE outlet_bc; // type of outlet bc\n"
"}BC_DATA_SIMP;\n"
"\n"
"typedef struct {\n"
"  int nb_sensor; // Number of sensors\n"
"  char **sensorName; // *sensorName[nb_sensor]: Name of sensor in FFD\n"
"  int **senIndex; // senIndex[nb_sensor][3]: i, j, k Index of sensors\n"
"  REAL *senVal; // senVal[nb_sensor]: Instantiate value of sensor point\n"
"  REAL *senValMean; // snValMean[nb_sensor]: Time averaged value of senVal;\n"
"  REAL TRoo; // Volumed averaged value of temperature in the space\n"
"  REAL TRooMean; // Time averaged value of TRoo;\n"
"  REAL ***coordMoniPoints; //coordMoniPoints[A][B][C]-> A: which rack; B: which monitor point; C: which coordinate\n"
"  int ***indexMoniPoints; // indexMoniPoints[A][B][C]-> A: which rack; B: which monitor point; C: which coordinate\n"
"} SENSOR_DATA;\n"
"\n"
"typedef struct {\n"
"  int nb_sensor; // Number of sensors\n"
"  REAL TRoo; // Volumed averaged value of temperature in the space\n"
"  REAL TRooMean; // Time averaged value of TRoo;\n"
"} SENSOR_DATA_SIMP;\n"
"\n"
"typedef struct {\n"
"  double dt; // FFD simulation time step size\n"
"  double t; // Internal: current time\n"
"  REAL t_steady; // Necessary time for reaching the steady state from initial condition\n"
"  int step_total; // The interval of iteration step to output data\n"
"  int step_current; // Internal: current iteration step\n"
"  int step_mean; // Internal: steps for time average\n"
"  REAL t_start; // Internal: clock time when simulation starts\n"
"  REAL t_end; // Internal: clock time when simulation ends\n"
"}TIME_DATA;\n"
"\n"
"typedef struct {\n"
"  REAL dt; // FFD simulation time step size\n"
"  REAL t; // Internal: current time\n"
"  REAL t_steady; // Necessary time for reaching the steady state from initial condition\n"
"  int step_total; // The interval of iteration step to output data\n"
"  int step_current; // Internal: current iteration step\n"
"  int step_mean; // Internal: steps for time average\n"
"  REAL t_start; // Internal: clock time when simulation starts\n"
"  REAL t_end; // Internal: clock time when simulation ends\n"
"}GPU_TIME_DATA;\n"
"\n"
"typedef struct {\n"
"  SOLVERTYPE solver;  // Solver type: GS, TDMA\n"
"  int check_residual; // 1: check, 0: donot check\n"
"	int check_conservation; //1: check, 0 : donot check residual after iterative solver\n"
"  ADVECTION advection_solver; // Type of advection solver: SEMI, LAX, UPWIND, UPWIND_NEW\n"
"  INTERPOLATION interpolation; // Interpolation in semi-Lagrangian method: BILINEAR, FSJ, HYBRID\n"
"  int cosimulation;  // 0: single; 1: coupled simulation\n"
"  int nextstep; // Internal: 1: yes; 0: no, wait\n"
"  int swipe_adv; // swipe numbers in GS for advection, if using implicit scheme\n"
"  int swipe_dif; // swipe numbers in GS for diffusion\n"
"  int swipe_pro; // swipe numbers in GS for projection\n"
"	TILE_FLOW_CORRECTION tile_flow_correct; // how to correct the flow rates at tiles\n"
"  int mass_conservation_on; // apply forced mass conservation or not\n"
"}SOLV_DATA;\n"
"\n"
"typedef struct {\n"
"  REAL T; // Initial temperature\n"
"  REAL u; // Initial velocity for u\n"
"  REAL v; // Initial velocity for v\n"
"  REAL w; // Initial velocity for w\n"
"}INIT_DATA;\n"
"\n"
"typedef struct {\n"
"  GEOM_DATA  *geom;\n"
"  INPU_DATA  *inpu;\n"
"  OUTP_DATA  *outp;\n"
"  PROB_DATA  *prob;\n"
"  TIME_DATA  *mytime;\n"
"  BC_DATA    *bc;\n"
"  SOLV_DATA  *solv;\n"
"  SENSOR_DATA *sens;\n"
"  INIT_DATA *init;\n"
"}PARA_DATA;\n"
"\n"
"typedef struct {\n"
"  GEOM_DATA  geom;\n"
"  OUTP_DATA_SIMP  outp_simp;\n"
"  PROB_DATA  prob;\n"
"  GPU_TIME_DATA  mytime;\n"
"  BC_DATA_SIMP  bc_simp;\n"
"  SOLV_DATA  solv;\n"
"  SENSOR_DATA_SIMP sens_simp;\n"
"  INIT_DATA init;\n"
"}PARA_DATA_SIMP;\n"
"\n"
"typedef struct {\n"
"  REAL number0;\n"
"  REAL number1;\n"
"  int command;\n"
"} ReceivedData;\n"
"\n"
"typedef struct {\n"
"  int feedback;\n"
"} SentCommand;\n"
"\n"
"typedef struct {\n"
"  REAL number0;\n"
"  REAL number1;\n"
"  int command;\n"
"}SentData;\n"
"\n"
"typedef struct {\n"
"  int feedback;\n"
"}ReceivedCommand;\n"
"\n"
"__constant static char msg[1000]={0};\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// Overview of the functions used in the kernels (shown in the next section)\n"
"///\n"
"/// Disclaimer:the codes are of absolute NO warranties in any form. Use at own risks.\n"
"///\n"
"/// author: Wei Tian, w.tian@umaimi.edu\n"
"///\n"
"/// date:   08/08/2017\n"
"///\n"
"/// The author acknowledges Tom Sevilla for providing assistance in debugging the codes.\n"
"///\n"
"/// Recent updates:\n"
"///\n"
"/// add chen's zero equation model and convective heat transfer coefficient\n"
"///\n"
"///\n"
"/// ALL RIGHTS RESERVED @2018\n"
"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// func. 0: REAL length_x(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp)\n"
"/// func. 1: REAL length_y(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp)\n"
"/// func. 2: REAL length_z(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp)\n"
"/// func. 3: REAL area_xy(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp)\n"
"/// func. 4: REAL area_zx(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp)\n"
"/// func. 5: REAL area_yz(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp)\n"
"/// func. 6: REAL interpolation(__global PARA_DATA_SIMP *para, __global REAL *d0, REAL *x_1p, REAL *y_1p, REAL *z_1p,\n"
"///                   int *pp, int *qp, int *rp)\n"
"/// func. 7: void set_x_location(__global PARA_DATA_SIMP *para, __global REAL *var, __global REAL *flag, __global REAL *x, REAL *u0p,\n"
"///                    int *ip, int *jp, int *kp,\n"
"///                    REAL *OL, int *OC, int *LOC, int *COOD)\n"
"/// func. 8: void set_y_location(__global PARA_DATA_SIMP *para, __global REAL *var, __global REAL *flag, __global REAL *y, REAL *v0p,\n"
"///                    int *ip, int *jp, int *kp,\n"
"///                    REAL *OL, int *OC, int *LOC, int *COOD)\n"
"/// func. 9: void set_z_location(__global PARA_DATA_SIMP *para, __global REAL *var, __global REAL *flag, __global REAL *z, REAL *w0p,\n"
"///                    int *ip, int *jp, int *kp,\n"
"///                    REAL *OL, int *OC, int *LOC, int *COOD)\n"
"/// func. 10: REAL nu_t_chen_zero_equ(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp)\n"
"/// func. 11: REAL h_coef (__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp, int *dp)\n"
"/// func. 12:\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"\n"
"//#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// check lenth X\n"
"/// 6/7/2015\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"REAL length_x(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp) {\n"
"  int i = ip[0],j = jp[0],k = kp[0];\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax, kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  if(i==0)\n"
"    return 0;\n"
"  else\n"
"    return (REAL) fabs(var[GX*size+IX(i,j,k)]-var[GX*size+IX(i-1,j,k)]);\n"
"}\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// check lenth Y\n"
"/// 6/7/2015\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"REAL length_y(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp) {\n"
"  int i = ip[0],j = jp[0],k = kp[0];\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax, kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"\n"
"  if(j==0)\n"
"    return 0;\n"
"  else\n"
"    return (REAL) fabs(var[GY*size+IX(i,j,k)]-var[GY*size+IX(i,j-1,k)]);\n"
"} // End of length_y()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// check lenth Z\n"
"/// 6/7/2015\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"REAL length_z(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp) {\n"
"  int i = ip[0],j = jp[0],k = kp[0];\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax, kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"\n"
"  if(k==0)\n"
"    return 0;\n"
"  else\n"
"    return (REAL) fabs(var[GZ*size+IX(i,j,k)]-var[GZ*size+IX(i,j,k-1)]);\n"
"} // End of length_z()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// check area_xy area\n"
"/// 6/7/2015\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"REAL area_xy(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp) {\n"
"  return length_x(para, var, ip, jp, kp)\n"
"       * length_y(para, var, ip, jp, kp);\n"
"}\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// check area_zx area\n"
"/// 6/7/2015\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"\n"
"REAL area_zx(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp) {\n"
"  return length_z(para, var, ip, jp, kp)\n"
"       * length_x(para, var, ip, jp, kp);\n"
"} // End of area_zx()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// check area_yz area\n"
"/// 6/7/2015\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"REAL area_yz(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp) {\n"
"  return length_y(para, var, ip, jp, kp)\n"
"       * length_z(para, var, ip, jp, kp);\n"
"} // End of area_yz();\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// Bilinear interpolation for advection\n"
"/// 6/17/2015\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"REAL interpolation(__global PARA_DATA_SIMP *para, __global REAL *d0, REAL *x_1p, REAL *y_1p, REAL *z_1p,\n"
"                   int *pp, int *qp, int *rp) {\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax, kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size = (imax+2)*(jmax+2)*(kmax+2);\n"
"  int p = pp[0], q = qp[0],r = rp[0];\n"
"  REAL x_1 = x_1p[0],y_1 = y_1p[0],z_1 = z_1p[0];\n"
"  REAL x_0, y_0, z_0;\n"
"  REAL tmp0, tmp1;\n"
"  REAL d000, d010, d100, d110;\n"
"  REAL d001, d011, d101, d111;\n"
"\n"
"  // assign the coefficients\n"
"  d000 = d0[IX(p,q,r)];\n"
"  d010 = d0[IX(p,q+1,r)];\n"
"  d100 = d0[IX(p+1,q,r)];\n"
"  d110 = d0[IX(p+1,q+1,r)];\n"
"  d001 = d0[IX(p,q,r+1)];\n"
"  d011 = d0[IX(p,q+1,r+1)];\n"
"  d101 = d0[IX(p+1,q,r+1)];\n"
"  d111 = d0[IX(p+1,q+1,r+1)];\n"
"\n"
"  // interpolation\n"
"  x_0 = (REAL) 1.0 - x_1;\n"
"  y_0 = (REAL) 1.0 - y_1;\n"
"  z_0 = (REAL) 1.0 - z_1;\n"
"\n"
"  tmp0 = x_0*(y_0*d000+y_1*d010) + x_1*(y_0*d100+y_1*d110);\n"
"  tmp1 = x_0*(y_0*d001+y_1*d011) + x_1*(y_0*d101+y_1*d111);\n"
"\n"
"  return z_0*tmp0+z_1*tmp1;\n"
"\n"
"} // End of interpolation()\n"
"\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// sub_function for advection of vectors: Find x location\n"
"/// 6/16/2015\n"
"// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"void set_x_location(__global PARA_DATA_SIMP *para, __global REAL *var, __global REAL *flag, __global REAL *x, REAL *u0p,\n"
"                    int *ip, int *jp, int *kp,\n"
"                    REAL *OL, int *OC, int *LOC, int *COOD) {\n"
"    int i = ip[0],j = jp[0],k = kp[0];\n"
"  REAL u0 = u0p[0];\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"\n"
"/****************************************************************************\n"
"  | If the previous location is equal to current position\n"
"  | stop the process (COOD[X] = 0)\n"
"  ****************************************************************************/\n"
"  if(OL[X]==x[IX(OC[X],OC[Y],OC[Z])])\n"
"    COOD[X]=0;\n"
" /****************************************************************************\n"
"  | Otherwise, if previous location is on the west of the current position\n"
"  ****************************************************************************/\n"
"  else if(OL[X]<x[IX(OC[X],OC[Y],OC[Z])]) {\n"
"    // If donot reach the boundary yet, move to west\n"
"    if(OC[X]>0)\n"
"      OC[X] -=1;\n"
"\n"
"    // If the previous position is on the east of new location, stop the process\n"
"    if(OL[X]>=x[IX(OC[X],OC[Y],OC[Z])])\n"
"\n"
"      COOD[X]=0;\n"
"\n"
"    // If the new position is solid\n"
"    if(flag[IX(OC[X],OC[Y],OC[Z])]==1) {\n"
"      // Use the east cell for new location\n"
"      OL[X] = x[IX(OC[X]+1,OC[Y],OC[Z])];\n"
"      OC[X] +=1;\n"
"      // Hit the boundary\n"
"      LOC[X] = 0;\n"
"      // Stop the trace process\n"
"      COOD[X] = 0;\n"
"    } // End of if() for solid\n"
"\n"
"    // If the new position is inlet or outlet\n"
"    if(flag[IX(OC[X],OC[Y],OC[Z])]==0||flag[IX(OC[X],OC[Y],OC[Z])]==2) {\n"
"      // Use new position\n"
"      OL[X] = x[IX(OC[X],OC[Y],OC[Z])];\n"
"      // use east cell for coordinate\n"
"      OC[X] += 1;\n"
"      // Hit the boundary\n"
"      LOC[X] = 0;\n"
"      // Stop the trace process\n"
"      COOD[X]=0;\n"
"    } // End of if() for inlet or outlet\n"
"  } // End of if() for previous position is on the west of new position\n"
"  /****************************************************************************\n"
"  | Otherwise, if previous location is on the east of the current position\n"
"  ****************************************************************************/\n"
"  else {\n"
"    // If not at the east boundary\n"
"    if(OC[X]<=imax)\n"
"      // Move to east\n"
"      OC[X] +=1;\n"
"\n"
"    // If the previous position is  on the west of new position\n"
"    if(OL[X]<=x[IX(OC[X],OC[Y],OC[Z])])\n"
"      // Stop the trace process\n"
"      COOD[X]=0;\n"
"\n"
"    // If the cell is solid\n"
"    if(flag[IX(OC[X],OC[Y],OC[Z])]==1) {\n"
"      // Use west cell\n"
"      OL[X] = x[IX(OC[X]-1,OC[Y],OC[Z])];\n"
"      OC[X] -= 1;\n"
"      // Hit the boundary\n"
"      LOC[X] = 0;\n"
"      // Stop the trace process\n"
"      COOD[X] = 0;\n"
"    } // End of if() for solid\n"
"\n"
"    // If the new position is inlet or outlet\n"
"    if(flag[IX(OC[X],OC[Y],OC[Z])]==0||flag[IX(OC[X],OC[Y],OC[Z])]==2) {\n"
"      // Use the current cell for previous location\n"
"      OL[X] = x[IX(OC[X],OC[Y],OC[Z])];\n"
"      // Use the west cell for coordinate\n"
"      OC[X] -=1;\n"
"      // Hit the boundary\n"
"      LOC[X] = 0;\n"
"      // Stop the trace process\n"
"      COOD[X]=0;\n"
"    } // End of if() for inlet or outlet\n"
"  } // End of if() for previous position is on the east of new position\n"
"} // End of set_x_location()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// sub_function for advection of vectors: Find y location\n"
"/// 6/16/2015\n"
"// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"void set_y_location(__global PARA_DATA_SIMP *para, __global REAL *var, __global REAL *flag, __global REAL *y, REAL *v0p,\n"
"                    int *ip, int *jp, int *kp,\n"
"                    REAL *OL, int *OC, int *LOC, int *COOD) {\n"
"    int i = ip[0],j = jp[0],k = kp[0];\n"
"  REAL v0 = v0p[0];\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"\n"
"  /****************************************************************************\n"
"  | If the previous location is equal to current position,\n"
"  | stop the process (COOD[X] = 0)\n"
"  ****************************************************************************/\n"
"  if(OL[Y]==y[IX(OC[X],OC[Y],OC[Z])])\n"
"    COOD[Y] = 0;\n"
"  /****************************************************************************\n"
"  | Otherwise, if previous location is on the south of the current position\n"
"  ****************************************************************************/\n"
"  else if(OL[Y]<y[IX(OC[X],OC[Y],OC[Z])]) {\n"
"    // If donot reach the boundary yet\n"
"    if(OC[Y]>0)\n"
"      OC[Y] -= 1;\n"
"\n"
"    // If the previous position is on the north of new location\n"
"    if(OL[Y]>=y[IX(OC[X],OC[Y],OC[Z])])\n"
"      // Stop the process\n"
"      COOD[Y] = 0;\n"
"\n"
"    // If the new position is solid\n"
"    if(flag[IX(OC[X],OC[Y],OC[Z])]==1) {\n"
"      // Use the north cell for new location\n"
"      OL[Y] = y[IX(OC[X],OC[Y]+1,OC[Z])];\n"
"      OC[Y] += 1;\n"
"      // Hit the boundary\n"
"      LOC[Y] = 0;\n"
"      // Stop the trace process\n"
"      COOD[Y] = 0;\n"
"    } // End of if() for solid\n"
"\n"
"    // If the new position is inlet or outlet\n"
"    if(flag[IX(OC[X],OC[Y],OC[Z])]==0||flag[IX(OC[X],OC[Y],OC[Z])]==2) {\n"
"      // Use new position\n"
"      OL[Y] = y[IX(OC[X],OC[Y],OC[Z])];\n"
"      // Use north cell for coordinate\n"
"      OC[Y] += 1;\n"
"      // Hit the boundary\n"
"      LOC[Y] = 0;\n"
"      // Stop the trace process\n"
"      COOD[Y] = 0;\n"
"    } // End of if() for inlet or outlet\n"
"  } // End of if() for previous position is on the south of new position\n"
"  /****************************************************************************\n"
"  | Otherwise, if previous location is on the north of the current position\n"
"  ****************************************************************************/\n"
"  else {\n"
"    // If not at the north boundary\n"
"    if(OC[Y]<=jmax)\n"
"      // Move to north\n"
"      OC[Y] +=1;\n"
"\n"
"    // If the previous position is on the south of new position\n"
"    if(OL[Y]<=y[IX(OC[X],OC[Y],OC[Z])])\n"
"      // Stop the trace process\n"
"      COOD[Y] = 0;\n"
"\n"
"    // If the cell is solid\n"
"    if(flag[IX(OC[X],OC[Y],OC[Z])]==1) {\n"
"      // Use south cell\n"
"      OL[Y] = y[IX(OC[X],OC[Y]-1,OC[Z])];\n"
"      OC[Y] -= 1;\n"
"      // Hit the boundary\n"
"      LOC[Y] = 0;\n"
"      // Stop the trace process\n"
"      COOD[Y] = 0;\n"
"    } // End of if() for solid\n"
"\n"
"    // If the new position is inlet or outlet\n"
"    if(flag[IX(OC[X],OC[Y],OC[Z])]==0||flag[IX(OC[X],OC[Y],OC[Z])]==2) {\n"
"      // Use the current cell for previous location\n"
"      OL[Y] = y[IX(OC[X],OC[Y],OC[Z])];\n"
"      // Use the south cell for coordinate\n"
"      OC[Y] -= 1;\n"
"      // Hit the boundary\n"
"      LOC[Y]=0;\n"
"      // Stop the trace process\n"
"      COOD[Y]=0;\n"
"    } // End of if() for inlet or outlet\n"
"  } // End of if() for previous position is on the east of new position\n"
"} // End of set_y_location()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// sub_function for advection of vectors: Find z location\n"
"/// 6/16/2015\n"
"// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"void set_z_location(__global PARA_DATA_SIMP *para, __global REAL *var, __global REAL *flag, __global REAL *z, REAL *w0p,\n"
"                    int *ip, int *jp, int *kp,\n"
"                    REAL *OL, int *OC, int *LOC, int *COOD) {\n"
"    int i = ip[0],j = jp[0],k = kp[0];\n"
"  REAL w0 = w0p[0];\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"\n"
"  /****************************************************************************\n"
"  | If the previous location is equal to current position,\n"
"  | stop the process (COOD[Z] = 0)\n"
"  ****************************************************************************/\n"
"  if(OL[Z]==z[IX(OC[X],OC[Y],OC[Z])])\n"
"    COOD[Z] = 0;\n"
"  /****************************************************************************\n"
"  | Otherwise, if previous location is on the floor of the current position\n"
"  ****************************************************************************/\n"
"  else if(OL[Z]<z[IX(OC[X],OC[Y],OC[Z])]) {\n"
"    // If donot reach the boundary yet\n"
"    if(OC[Z]>0)\n"
"      OC[Z] -= 1;\n"
"\n"
"    // If the previous position is on the ceiling of new location\n"
"    if(OL[Z]>=z[IX(OC[X],OC[Y],OC[Z])])\n"
"      // Stop the process\n"
"      COOD[Z] = 0;\n"
"\n"
"    // If the new position is solid\n"
"    if(flag[IX(OC[X],OC[Y],OC[Z])]==1) {\n"
"      // Use the ceiling cell for new location\n"
"      OL[Z] = z[IX(OC[X],OC[Y],OC[Z]+1)];\n"
"      OC[Z] += 1;\n"
"      // Hit the boundary\n"
"      LOC[Z] = 0;\n"
"      // Stop the trace process\n"
"      COOD[Z] = 0;\n"
"    } // End of if() for solid\n"
"\n"
"    // If the new position is inlet or outlet\n"
"    if(flag[IX(OC[X],OC[Y],OC[Z])]==0||flag[IX(OC[X],OC[Y],OC[Z])]==2) {\n"
"      // Use new position\n"
"      OL[Z] = z[IX(OC[X],OC[Y],OC[Z])];\n"
"      // Use ceiling cell for coordinate\n"
"      OC[Z] += 1;\n"
"      // Hit the boundary\n"
"      LOC[Z] = 0;\n"
"      // Stop the trace process\n"
"      COOD[Z] = 0;\n"
"    } // End of if() for inlet or outlet\n"
"  } // End of if() for previous position is on the floor of new position\n"
"  /****************************************************************************\n"
"  | Otherwise, if previous location is on the ceiling of the current position\n"
"  -***************************************************************************/\n"
"  else {\n"
"    // If not at the ceiling boundary\n"
"    if(OC[Z]<=kmax)\n"
"      // Move to ceiling\n"
"      OC[Z] += 1;\n"
"\n"
"    // If the previous position is on the floor of new position\n"
"    if(OL[Z] <=z[IX(OC[X],OC[Y],OC[Z])])\n"
"      // Stop the trace process\n"
"      COOD[Z] = 0;\n"
"\n"
"    // If the cell is solid\n"
"    if(flag[IX(OC[X],OC[Y],OC[Z])]==1) {\n"
"      // Use floor cell\n"
"      OL[Z] = z[IX(OC[X],OC[Y],OC[Z]-1)];\n"
"      OC[Z] -= 1;\n"
"      // Hit the boundary\n"
"      LOC[Z] = 0;\n"
"      // Stop the trace process\n"
"      COOD[Z] = 0;\n"
"    } // End of if() for solid\n"
"\n"
"    // If the new position is inlet or outlet\n"
"    if(flag[IX(OC[X],OC[Y],OC[Z])]==0||flag[IX(OC[X],OC[Y],OC[Z])]==2) {\n"
"      // Use the current cell for previous location\n"
"      OL[Z]=z[IX(OC[X],OC[Y],OC[Z])];\n"
"      // Use the floor cell for coordinate\n"
"      OC[Z] -= 1;\n"
"      // Hit the boundary\n"
"      LOC[Z]=0;\n"
"      // Stop the trace process\n"
"      COOD[Z]=0;\n"
"    } // End of if() for inlet or outlet\n"
"  } // End of if() for previous position is on the east of new position\n"
"} // End of set_z_location()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// functions to calculate the turbulent viscosity/thermal diffusivity using Chen's zero equation\n"
"/// 8/08/2017\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"REAL nu_t_chen_zero_equ(__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp){\n"
"\n"
"  int i = ip[0],j = jp[0],k = kp[0];\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"  REAL l= 0.0;\n"
"  REAL lx=0.0,ly=0.0,lz=0.0;\n"
"  REAL jim_a = 0.0185;\n"
"  REAL coeff = para->prob.chen_a;\n"
"  REAL nu_t;\n"
"\n"
"  __global float *u = &var[VX*size];\n"
"  __global float *v = &var[VY*size];\n"
"  __global float *w = &var[VZ*size];\n"
"  __global float *flagp = &var[FLAGP*size];\n"
"  __global float *x = &var[X*size];\n"
"  __global float *y = &var[Y*size];\n"
"  __global float *z = &var[Z*size];\n"
"  \n"
"  //lx = min(x[IX(i,j,k)]-x[IX(0,j,k)],x[IX(imax+1,j,k)]-x[IX(i,j,k)]);\n"
"  //ly = min(y[IX(i,j,k)]-y[IX(i,0,k)],y[IX(i,jmax+1,k)]-y[IX(i,j,k)]);\n"
"  //lz = min(z[IX(i,j,k)]-z[IX(i,j,0)],z[IX(i,j,kmax+1)]-z[IX(i,j,k)]);\n"
"  \n"
"  //l = min(lx,ly);\n"
"  //l = min(l,lz);\n"
"  l = var[MIN_DISTANCE*size + IX(i, j, k)];\n"
"\n"
"  if (flagp[IX(i - 1, j, k)] >= 0 || flagp[IX(i + 1, j, k)] >= 0 ||\n"
"        flagp[IX(i, j - 1, k)] >= 0 || flagp[IX(i, j + 1, k)] >= 0 ||\n"
"        flagp[IX(i, j, k - 1)] >= 0 || flagp[IX(i, j, k + 1)] >= 0) {\n"
"        //if the cell is adjacent to solid boundaries, assign a otherwise coffecient\n"
"        coeff = jim_a;\n"
"  }\n"
"  else {\n"
"        // if the cell is not adjacent to solid boundaries, assign a standard coffecient\n"
"        coeff = para->prob.chen_a;\n"
"    }\n"
"\n"
"  nu_t = coeff * l\n"
"        * (REAL)sqrt(u[IX(i,j,k)]*u[IX(i,j,k)]\n"
"                    +v[IX(i,j,k)]*v[IX(i,j,k)]\n"
"                    +w[IX(i,j,k)]*w[IX(i,j,k)] );\n"
"\n"
"  return nu_t;\n"
"}\n"
"\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// functions to calculate convective heat transfer coefficient\n"
"/// 8/14/2017\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"REAL h_coef (__global PARA_DATA_SIMP *para, __global REAL *var, int *ip, int *jp, int *kp, int *dp) {\n"
"  REAL D = dp[0];\n"
"  REAL nu = para->prob.nu;\n"
"  REAL rhoCp = para->prob.rho * para->prob.Cp;\n"
"  REAL coef_h=para->prob.coeff_h;\n"
"  REAL h, kapa;\n"
"\n"
"  if (para->prob.tur_model == LAM) {\n"
"    return coef_h*rhoCp;\n"
"  }\n"
"  else if (para->prob.tur_model == CONSTANT) {\n"
"    return coef_h*rhoCp*101;\n"
"  }\n"
"  else if (para->prob.tur_model == CHEN) {\n"
"    kapa = nu + nu_t_chen_zero_equ(para, var, ip, jp, kp);\n"
"    h = (rhoCp* para->prob.alpha / D) *(kapa / nu);\n"
"    return h;\n"
"  }\n"
"  else\n"
"    return coef_h*rhoCp;\n"
"\n"
"}// end of h_coef\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// brief the functions of kernels.\n"
"///\n"
"/// Disclaimer:the codes are of absolute NO warranties in any form. Use at own risks.\n"
"///\n"
"/// define all the kernels that run on the multi-core devices, like CPUs, GPUs\n"
"///\n"
"/// author: Wei Tian, w.tian@umiami.edu\n"
"/// date:   08/08/2017\n"
"///\n"
"/// The author acknowledges Tom Sevilla for providing assistance in debugging the codes.\n"
"///\n"
"/// Recent updates:\n"
"///\n"
"/// add implicit scheme to the advection terms\n"
"///\n"
"/// advection may not be vectorized perfectly. Need improvement.\n"
"///\n"
"/// use existing parallel libraries for solving the quation. The libray should be\n"
"///  independent of the platforms, or, at least should be compatible to NVIDIA platform.\n"
"///\n"
"/// ALL RIGHTS RESERVED @2017\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// 0: void adve_VX(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX)\n"
"/// 1: void adve_VY(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX)\n"
"/// 2: void adve_VZ(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX)\n"
"/// 3: void adve_T(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX)\n"
"/// 4: void diff_VX(__global PARA_DATA_SIMP *para, __global REAL *var,  __global  int *BINDEX)\n"
"/// 5: void diff_VY(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX)\n"
"/// 6: void diff_VZ(__global PARA_DATA_SIMP *para, __global REAL *var,  __global  int *BINDEX)\n"
"/// 7: void diff_T(__global PARA_DATA_SIMP *para, __global REAL *var,  __global  int *BINDEX)\n"
"/// 8: void project(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX)\n"
"/// 9: void project_velo_corr(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX)\n"
"/// 10: void Ax_BSolver(__global PARA_DATA_SIMP *para, __global REAL *var,__global int *index, __global int *WF)\n"
"/// 11: void Ax_BSolver_P(__global PARA_DATA_SIMP *para, __global REAL *var)\n"
"/// 12: void ap_coeff(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *var_type)\n"
"/// 13: set_bnd_T(__global PARA_DATA_SIMP *para, __global REAL *var, __global REAL *psi, __global int *BINDEX)\n"
"/// 14: set_bnd_pressure(__global PARA_DATA_SIMP *para, __global REAL *var,__global int *BINDEX)\n"
"/// 15: set_bnd_VX(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *WF, __global int *BINDEX)\n"
"/// 16: set_bnd_VY(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *WF, __global int *BINDEX)\n"
"/// 17: set_bnd_VZ(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *WF, __global int *BINDEX)\n"
"/// 18: adjust_velocity(PARA_DATA *para, REAL **var, int **BINDEX)\n"
"/// 19: mass_conservation(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX)\n"
"/// 20: void reset_time_averaged_data(__global PARA_DATA_SIMP *para, __global REAL *var)\n"
"/// 21: void add_time_averaged_data(__global PARA_DATA_SIMP *para, __global REAL *var)\n"
"/// 22: void time_averaged(__global PARA_DATA_SIMP *para, __global REAL *var)\n"
"/// 23: void Ax_BSolver_upd(__global PARA_DATA_SIMP *para, __global REAL *var,__global int *index, __global int *WF)\n"
"/// 24: void Ax_BSolver_P_upd(__global PARA_DATA_SIMP *para, __global REAL *var)\n"
"/// 25: void adve_VX_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX)\n"
"/// 26: void adve_VY_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX)\n"
"/// 27: void adve_VZ_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX)\n"
"/// 28: void adve_T_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX)\n"
"/// 29: void ap_im_coeff(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *var_type)\n"
"/// 30: set_bnd_T_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX)\n"
"/// 31: set_bnd_VX_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX)\n"
"/// 32: set_bnd_VY_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX)\n"
"/// 33: set_bnd_VZ_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX)\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl setting diffusion coefficient for VX\n"
"/// 6/7/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void diff_VX(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX) {\n"
"\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int bar =0;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  REAL stan_coef = para->prob.coef_stanchion;\n"
"\n"
"  __global float *psi = &var[VX*size];\n"
"  __global float *psi0 = &var[TMP1*size];\n"
"  __global float *aw = &var[AW*size];\n"
"  __global float *ae = &var[AE*size];\n"
"  __global float *as = &var[AS*size];\n"
"  __global float *an = &var[AN*size];\n"
"  __global float *af = &var[AF*size];\n"
"  __global float *ab = &var[AB*size];\n"
"  __global float *ap = &var[AP*size];\n"
"  __global float *ap0 = &var[AP0*size];\n"
"  __global float *b = &var[B*size];\n"
"  __global float *gx = &var[GX*size];\n"
"  __global float *x = &var[X*size];\n"
"  __global float *y = &var[Y*size];\n"
"  __global float*z = &var[Z*size];\n"
"  __global float *gy = &var[GY*size];\n"
"  __global float *gz = &var[GZ*size];\n"
"  __global float *pp = &var[PP*size];\n"
"  __global float *Temp = &var[TEMP*size];\n"
"  __global float *flagp = &var[FLAGP*size];\n"
"\n"
"  REAL dxe, dxw, dyn, dys, dzf, dzb, Dx, Dy, Dz;\n"
"  REAL dt = para->mytime.dt, beta = para->prob.beta;\n"
"  REAL Temp_Buoyancy = para->prob.Temp_Buoyancy;\n"
"  REAL gravx = para->prob.gravx, gravy = para->prob.gravy,\n"
"       gravz = para->prob.gravz;\n"
"  REAL kapa=para->prob.nu;\n"
"  REAL coef_CONSTANT = 120;\n"
"\n"
"  // FOR_U_CELL\n"
"  if (i>0 && i<imax && j>0 && j<jmax+1 && k>0 && k<kmax+1) {\n"
"\n"
"    if (para->prob.tur_model==CHEN) {\n"
"        kapa = nu_t_chen_zero_equ(para, var, &i, &j, &k)+ para->prob.nu;\n"
"    }\n"
"\n"
"\n"
"    dxe = gx[IX(i+1,j  ,k)] - gx[IX(i  ,j,k)];\n"
"    dxw = gx[IX(i  ,j  ,k)] - gx[IX(i-1,j,k)];\n"
"    dyn =  y[IX(i  ,j+1,k)] -  y[IX(i  ,j,k)];\n"
"    dys =  y[IX(i,j,k)] -      y[IX(i,j-1,k)];\n"
"    dzf =  z[IX(i,j,k+1)] -    z[IX(i,j,k)];\n"
"    dzb =  z[IX(i,j,k)] -      z[IX(i,j,k-1)];\n"
"    Dx =   x[IX(i+1,j,k)] -    x[IX(i,j,k)];\n"
"    Dy =  gy[IX(i,j,k)] -     gy[IX(i,j-1,k)];\n"
"    Dz =  gz[IX(i,j,k)] -     gz[IX(i,j,k-1)];\n"
"\n"
"    aw[IX(i,j,k)] = kapa*Dy*Dz/dxw;\n"
"    ae[IX(i,j,k)] = kapa*Dy*Dz/dxe;\n"
"    an[IX(i,j,k)] = kapa*Dx*Dz/dyn;\n"
"    as[IX(i,j,k)] = kapa*Dx*Dz/dys;\n"
"    af[IX(i,j,k)] = kapa*Dx*Dy/dzf;\n"
"    ab[IX(i,j,k)] = kapa*Dx*Dy/dzb;\n"
"    ap0[IX(i,j,k)] = Dx*Dy*Dz/dt;\n"
"    b[IX(i,j,k)] = psi0[IX(i,j,k)]*ap0[IX(i,j,k)]\n"
"                 - beta*gravx*(Temp[IX(i,j,k)]-Temp_Buoyancy)*Dx*Dy*Dz\n"
"                 + (pp[IX(i,j,k)]-pp[IX(i+1,j,k)])*Dy*Dz\n"
"                 - 0.5*stan_coef*psi0[IX(i,j,k)]*psi0[IX(i,j,k)]*Dx*Dy*Dz\n"
"                 + var[VXS*size+IX(i,j,k)]\n"
"                 + var[RESX*size+IX(i,j,k)]*psi0[IX(i,j,k)]*psi0[IX(i,j,k)]*Dy*Dz;\n"
"    // implicit linearization of the resistance RESX\n"
"    ap0[IX(i,j,k)] = Dx*Dy*Dz/dt + 2*var[RESX*size+IX(i,j,k)]*psi0[IX(i,j,k)]*Dy*Dz;\n"
"\n"
"  } //end of FOR_U_CELL\n"
"}// end of __kernel void diff_VX()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl setting advection coefficient for VX\n"
"/// 8/7/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void adve_VX_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"\n"
"  __global float *psi = &var[TMP1*size];\n"
"  __global float *psi0 = &var[VX*size];\n"
"  __global float *aw = &var[AW*size];\n"
"  __global float *ae = &var[AE*size];\n"
"  __global float *as = &var[AS*size];\n"
"  __global float *an = &var[AN*size];\n"
"  __global float *af = &var[AF*size];\n"
"  __global float *ab = &var[AB*size];\n"
"  __global float *ap0 = &var[AP0*size];\n"
"  __global float *b = &var[B*size];\n"
"  __global float *x = &var[X*size];\n"
"  __global float *y = &var[Y*size];\n"
"  __global float *z = &var[Z*size];\n"
"  __global float *gx = &var[GX*size];\n"
"  __global float *gy = &var[GY*size];\n"
"  __global float *gz = &var[GZ*size];\n"
"  __global float *u = &var[VX*size];\n"
"  __global float *v = &var[VY*size];\n"
"  __global float *w = &var[VZ*size];\n"
"\n"
"  REAL dxe, dxw, dyn, dys, dzf, dzb, Dx, Dy, Dz;\n"
"  REAL uw, ue, vs, vn, wb, wf;\n"
"  REAL Fw, Fe, Fs, Fn, Fb, Ff;\n"
"  REAL dt = para->mytime.dt;\n"
"\n"
"  if (i>0 && i<imax && j>0 && j<jmax+1 && k>0 && k<kmax+1) {\n"
"    // define the dimensions\n"
"    dxe = gx[IX(i + 1, j, k)] - gx[IX(i, j, k)];\n"
"    dxw = gx[IX(i, j, k)] - gx[IX(i - 1, j, k)];\n"
"    Dx = x[IX(i + 1, j, k)] - x[IX(i, j, k)];\n"
"    Dy = gy[IX(i, j, k)] - gy[IX(i, j - 1, k)];\n"
"    Dz = gz[IX(i, j, k)] - gz[IX(i, j, k - 1)];\n"
"\n"
"    // define the velocity at the surface\n"
"    uw = 0.5*(u[IX(i - 1, j, k)] + u[IX(i, j, k)]);\n"
"    ue = 0.5*(u[IX(i, j, k)] + u[IX(i + 1, j, k)]);\n"
"    vs = 0.5*(v[IX(i, j-1, k)] + v[IX(i + 1, j-1, k)]);\n"
"    vn = 0.5*(v[IX(i, j, k)] + v[IX(i + 1, j, k)]);\n"
"    wb = 0.5*(w[IX(i, j, k-1)] + w[IX(i+1, j, k-1)]);\n"
"    wf = 0.5*(w[IX(i, j, k)] + w[IX(i + 1, j, k)]);\n"
"\n"
"    // define the flow rate at the surface\n"
"    Fw = uw * Dy*Dz;\n"
"    Fe = ue * Dy*Dz;\n"
"    Fs = vs * Dx*Dz;\n"
"    Fn = vn * Dx*Dz;\n"
"    Fb = wb * Dx*Dy;\n"
"    Ff = wf * Dx*Dy;\n"
"\n"
"    // define the coefficient for calculation\n"
"    aw[IX(i, j, k)] = max (Fw, 0);\n"
"    ae[IX(i, j, k)] = max (-Fe, 0);\n"
"    as[IX(i, j, k)] = max(Fs, 0);\n"
"    an[IX(i, j, k)] = max (-Fn, 0);\n"
"    ab[IX(i, j, k)] = max(Fb, 0);\n"
"    af[IX(i, j, k)] = max (-Ff, 0);\n"
"    ap0[IX(i, j, k)] = Dx * Dy * Dz / dt;\n"
"    b[IX(i, j, k)] = psi0[IX(i, j, k)] * ap0[IX(i, j, k)];\n"
"\n"
"  } //end of if\n"
"}\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl setting diffusion coefficient for VY\n"
"/// 6/7/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"\n"
"__kernel void diff_VY(__global PARA_DATA_SIMP *para, __global REAL *var,  __global  int *BINDEX) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  REAL stan_coef = para->prob.coef_stanchion;\n"
"\n"
"  __global float *psi = &var[VY*size];\n"
"  __global float *psi0 = &var[TMP2*size];\n"
"\n"
"  __global float *aw = &var[AW*size];\n"
"  __global float *ae = &var[AE*size];\n"
"  __global float *as = &var[AS*size];\n"
"  __global float *an = &var[AN*size];\n"
"  __global float *af = &var[AF*size];\n"
"  __global float *ab = &var[AB*size];\n"
"  __global float *ap = &var[AP*size];\n"
"  __global float *ap0 = &var[AP0*size];\n"
"  __global float *b = &var[B*size];\n"
"  __global float *gx = &var[GX*size];\n"
"  __global float *x = &var[X*size];\n"
"  __global float *y = &var[Y*size];\n"
"  __global float *z = &var[Z*size];\n"
"  __global float *gy = &var[GY*size];\n"
"  __global float *gz = &var[GZ*size];\n"
"  __global float *pp = &var[PP*size];\n"
"  __global float *Temp = &var[TEMP*size];\n"
"  __global float *flagp = &var[FLAGP*size];\n"
"\n"
"  REAL dxe, dxw, dyn, dys, dzf, dzb, Dx, Dy, Dz;\n"
"  REAL dt = para->mytime.dt, beta = para->prob.beta;\n"
"  REAL Temp_Buoyancy = para->prob.Temp_Buoyancy;\n"
"  REAL gravx = para->prob.gravx, gravy = para->prob.gravy,\n"
"       gravz = para->prob.gravz;\n"
"  REAL kapa=para->prob.nu;\n"
"  REAL coef_CONSTANT = 120;\n"
"\n"
"  // FOR_V_CELL\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax && k>0 && k<kmax+1) {\n"
"\n"
"        if (para->prob.tur_model==CHEN) {\n"
"            kapa = nu_t_chen_zero_equ(para, var, &i, &j, &k)+ para->prob.nu;\n"
"        }\n"
"        dxe = x[IX(i+1,j,k)] - x[IX(i,j,k)];\n"
"        dxw = x[IX(i,j,k)] - x[IX(i-1,j,k)];\n"
"        dyn = gy[IX(i,j+1,k)] - gy[IX(i,j,k)];\n"
"        dys = gy[IX(i,j,k)] - gy[IX(i,j-1,k)];\n"
"        dzf = z[IX(i,j,k+1)] - z[IX(i,j,k)];\n"
"        dzb = z[IX(i,j,k)] - z[IX(i,j,k-1)];\n"
"        Dx = gx[IX(i,j,k)] - gx[IX(i-1,j,k)];\n"
"        Dy = y[IX(i,j+1,k)] - y[IX(i,j,k)];\n"
"        Dz = gz[IX(i,j,k)] - gz[IX(i,j,k-1)];\n"
"\n"
"        aw[IX(i,j,k)] = kapa*Dy*Dz/dxw;\n"
"        ae[IX(i,j,k)] = kapa*Dy*Dz/dxe;\n"
"        an[IX(i,j,k)] = kapa*Dx*Dz/dyn;\n"
"        as[IX(i,j,k)] = kapa*Dx*Dz/dys;\n"
"        af[IX(i,j,k)] = kapa*Dx*Dy/dzf;\n"
"        ab[IX(i,j,k)] = kapa*Dx*Dy/dzb;\n"
"        ap0[IX(i,j,k)] = Dx*Dy*Dz/dt;\n"
"        b[IX(i,j,k)] = psi0[IX(i,j,k)]*ap0[IX(i,j,k)]\n"
"                     - beta*gravy*(Temp[IX(i,j,k)]-Temp_Buoyancy)*Dx*Dy*Dz\n"
"                     + (pp[IX(i,j,k)]-pp[IX(i ,j+1,k)])*Dx*Dz\n"
"                     - 0.5*stan_coef*psi0[IX(i,j,k)]*psi0[IX(i,j,k)]*Dx*Dy*Dz\n"
"                     + var[VYS*size+IX(i,j,k)]\n"
"                     + var[RESY*size+IX(i,j,k)]*psi0[IX(i,j,k)]*psi0[IX(i,j,k)]*Dx*Dz;\n"
"        \n"
"        // implicit linearization of the resistance RESX\n"
"	    ap0[IX(i,j,k)] = Dx*Dy*Dz/dt + 2*var[RESY*size+IX(i,j,k)]*psi0[IX(i,j,k)]*Dx*Dz;\n"
"\n"
"  } //end of FOR_V_CELL\n"
"} //end of __kernel void diff_VY()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl setting advection coefficient for VY\n"
"/// 8/7/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void adve_VY_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"\n"
"  __global float *psi = &var[TMP2*size];\n"
"  __global float *psi0 = &var[VY*size];\n"
"  __global float *aw = &var[AW*size];\n"
"  __global float *ae = &var[AE*size];\n"
"  __global float *as = &var[AS*size];\n"
"  __global float *an = &var[AN*size];\n"
"  __global float *af = &var[AF*size];\n"
"  __global float *ab = &var[AB*size];\n"
"  __global float *ap0 = &var[AP0*size];\n"
"  __global float *b = &var[B*size];\n"
"  __global float *x = &var[X*size];\n"
"  __global float *y = &var[Y*size];\n"
"  __global float *z = &var[Z*size];\n"
"  __global float *gx = &var[GX*size];\n"
"  __global float *gy = &var[GY*size];\n"
"  __global float *gz = &var[GZ*size];\n"
"  __global float *u = &var[VX*size];\n"
"  __global float *v = &var[VY*size];\n"
"  __global float *w = &var[VZ*size];\n"
"\n"
"  REAL dxe, dxw, dyn, dys, dzf, dzb, Dx, Dy, Dz;\n"
"  REAL uw, ue, vs, vn, wb, wf;\n"
"  REAL Fw, Fe, Fs, Fn, Fb, Ff;\n"
"  REAL dt = para->mytime.dt;\n"
"\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax && k>0 && k<kmax+1) {\n"
"    // define the dimensions\n"
"    dyn = gy[IX(i, j + 1, k)] - gy[IX(i, j, k)];\n"
"    dys = gy[IX(i, j, k)] - gy[IX(i, j - 1, k)];\n"
"    Dx = gx[IX(i, j, k)] - gx[IX(i - 1, j, k)];\n"
"    Dy = y[IX(i, j + 1, k)] - y[IX(i, j, k)];\n"
"    Dz = gz[IX(i, j, k)] - gz[IX(i, j, k - 1)];\n"
"\n"
"    // define the velocity at the surface\n"
"    uw = 0.5*(u[IX(i - 1, j, k)] + u[IX(i - 1, j + 1, k)]);\n"
"    ue = 0.5*(u[IX(i, j, k)] + u[IX(i, j + 1, k)]);\n"
"    vs = 0.5*(v[IX(i, j - 1, k)] + v[IX(i, j, k)]);\n"
"    vn = 0.5*(v[IX(i, j, k)] + v[IX(i, j + 1, k)]);\n"
"    wb = 0.5*(w[IX(i, j, k - 1)] + w[IX(i, j + 1, k - 1)]);\n"
;


const char source_str2[] =
"    wf = 0.5*(w[IX(i, j, k)] + w[IX(i, j +1, k)]);\n"
"\n"
"    // define the flow rate at the surface\n"
"    Fw = uw * Dy*Dz;\n"
"    Fe = ue * Dy*Dz;\n"
"    Fs = vs * Dx*Dz;\n"
"    Fn = vn * Dx*Dz;\n"
"    Fb = wb * Dx*Dy;\n"
"    Ff = wf * Dx*Dy;\n"
"\n"
"    // define the coefficient for calculation\n"
"    aw[IX(i, j, k)] = max(Fw, 0);\n"
"    ae[IX(i, j, k)] = max(-Fe, 0);\n"
"    as[IX(i, j, k)] = max(Fs, 0);\n"
"    an[IX(i, j, k)] = max(-Fn, 0);\n"
"    ab[IX(i, j, k)] = max(Fb, 0);\n"
"    af[IX(i, j, k)] = max(-Ff, 0);\n"
"    ap0[IX(i, j, k)] = Dx * Dy * Dz / dt;\n"
"    b[IX(i, j, k)] = psi0[IX(i, j, k)] * ap0[IX(i, j, k)];\n"
"\n"
"  } //end of FOR_V_CELL\n"
"}\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl setting diffusion coefficient for VZ\n"
"/// 6/7/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"\n"
"__kernel void diff_VZ(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX) {\n"
"\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"\n"
"  __global float *psi = &var[VZ*size];\n"
"  __global float *psi0 = &var[TMP3*size];\n"
"\n"
"  __global float *aw = &var[AW*size];\n"
"  __global float *ae = &var[AE*size];\n"
"  __global float *as = &var[AS*size];\n"
"  __global float *an = &var[AN*size];\n"
"  __global float *af = &var[AF*size];\n"
"  __global float *ab = &var[AB*size];\n"
"  __global float *ap = &var[AP*size];\n"
"  __global float *ap0 = &var[AP0*size];\n"
"  __global float *b = &var[B*size];\n"
"  __global float *gx = &var[GX*size];\n"
"  __global float *x = &var[X*size];\n"
"  __global float *y = &var[Y*size];\n"
"  __global float*z = &var[Z*size];\n"
"  __global float *gy = &var[GY*size];\n"
"  __global float *gz = &var[GZ*size];\n"
"  __global float *pp = &var[PP*size];\n"
"  __global float *Temp = &var[TEMP*size];\n"
"  __global float *flagp = &var[FLAGP*size];\n"
"\n"
"  REAL dxe, dxw, dyn, dys, dzf, dzb, Dx, Dy, Dz;\n"
"  REAL dt = para->mytime.dt, beta = para->prob.beta;\n"
"  REAL Temp_Buoyancy = para->prob.Temp_Buoyancy;\n"
"  REAL gravx = para->prob.gravx, gravy = para->prob.gravy,\n"
"       gravz = para->prob.gravz;\n"
"  REAL kapa=para->prob.nu;\n"
"  REAL coef_CONSTANT = 120;\n"
"\n"
"  // FOR_W_CELL\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax) {\n"
"\n"
"    if (para->prob.tur_model==CHEN) {\n"
"        kapa = nu_t_chen_zero_equ(para, var, &i, &j, &k)+ para->prob.nu;\n"
"    }\n"
"\n"
"    dxe = x[IX(i+1,j,k)] - x[IX(i,j,k)];\n"
"    dxw = x[IX(i,j,k)] - x[IX(i-1,j,k)];\n"
"    dyn = y[IX(i,j+1,k)] - y[IX(i,j,k)];\n"
"    dys = y[IX(i,j,k)] - y[IX(i,j-1,k)];\n"
"    dzf = gz[IX(i,j,k+1)] - gz[IX(i,j,k)];\n"
"    dzb = gz[IX(i,j,k)] - gz[IX(i,j,k-1)];\n"
"    Dx = gx[IX(i,j,k)] - gx[IX(i-1,j,k)];\n"
"    Dy = gy[IX(i,j,k)] - gy[IX(i,j-1,k)];\n"
"    Dz = z[IX(i,j,k+1)] - z[IX(i,j,k)];\n"
"\n"
"    aw[IX(i,j,k)] = kapa*Dy*Dz/dxw;\n"
"    ae[IX(i,j,k)] = kapa*Dy*Dz/dxe;\n"
"    an[IX(i,j,k)] = kapa*Dx*Dz/dyn;\n"
"    as[IX(i,j,k)] = kapa*Dx*Dz/dys;\n"
"    af[IX(i,j,k)] = kapa*Dx*Dy/dzf;\n"
"    ab[IX(i,j,k)] = kapa*Dx*Dy/dzb;\n"
"    ap0[IX(i,j,k)] = Dx*Dy*Dz/dt;\n"
"    b[IX(i,j,k)] = psi0[IX(i,j,k)]*ap0[IX(i,j,k)]\n"
"                 - beta*gravz*(Temp[IX(i,j,k)]-Temp_Buoyancy)*Dx*Dy*Dz\n"
"                 + (pp[IX(i,j,k)]-pp[IX(i ,j,k+1)])*Dy*Dx\n"
"                 + var[VZS*size+IX(i,j,k)]\n"
"                 + var[RESZ*size+IX(i,j,k)]*psi0[IX(i,j,k)]*psi0[IX(i,j,k)]*Dx*Dy;\n"
"                 \n"
"    // implicit linearization of the resistance RESX\n"
"    ap0[IX(i,j,k)] = Dx*Dy*Dz/dt + 2*var[RESZ*size+IX(i,j,k)]*psi0[IX(i,j,k)]*Dx*Dy;\n"
"\n"
"  } //end of FOR_W_CELL\n"
"}// end of __kernel void diff_VZ()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl setting advection coefficient for VZ\n"
"/// 8/7/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void adve_VZ_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"\n"
"  __global float *psi = &var[TMP3*size];\n"
"  __global float *psi0 = &var[VZ*size];\n"
"  __global float *aw = &var[AW*size];\n"
"  __global float *ae = &var[AE*size];\n"
"  __global float *as = &var[AS*size];\n"
"  __global float *an = &var[AN*size];\n"
"  __global float *af = &var[AF*size];\n"
"  __global float *ab = &var[AB*size];\n"
"  __global float *ap0 = &var[AP0*size];\n"
"  __global float *b = &var[B*size];\n"
"  __global float *x = &var[X*size];\n"
"  __global float *y = &var[Y*size];\n"
"  __global float *z = &var[Z*size];\n"
"  __global float *gx = &var[GX*size];\n"
"  __global float *gy = &var[GY*size];\n"
"  __global float *gz = &var[GZ*size];\n"
"  __global float *u = &var[VX*size];\n"
"  __global float *v = &var[VY*size];\n"
"  __global float *w = &var[VZ*size];\n"
"\n"
"  REAL dxe, dxw, dyn, dys, dzf, dzb, Dx, Dy, Dz;\n"
"  REAL uw, ue, vs, vn, wb, wf;\n"
"  REAL Fw, Fe, Fs, Fn, Fb, Ff;\n"
"  REAL dt = para->mytime.dt;\n"
"\n"
"  // FOR_W_CELL\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax) {\n"
"    // define the dimensions\n"
"    dzf = gz[IX(i, j, k + 1)] - gz[IX(i, j, k)];\n"
"    dzb = gz[IX(i, j, k)] - gz[IX(i, j, k - 1)];\n"
"    Dx = gx[IX(i, j, k)] - gx[IX(i - 1, j, k)];\n"
"    Dy = gy[IX(i, j, k)] - gy[IX(i, j - 1, k)];\n"
"    Dz = z[IX(i, j, k + 1)] - z[IX(i, j, k)];\n"
"\n"
"    // define the velocity at the surface\n"
"    uw = 0.5*(u[IX(i - 1, j, k)] + u[IX(i - 1, j, k + 1)]);\n"
"    ue = 0.5*(u[IX(i, j, k)] + u[IX(i, j, k + 1)]);\n"
"    vs = 0.5*(v[IX(i, j - 1, k)] + v[IX(i, j - 1, k + 1)]);\n"
"    vn = 0.5*(v[IX(i, j, k)] + v[IX(i, j, k + 1)]);\n"
"    wb = 0.5*(w[IX(i, j, k - 1)] + w[IX(i, j, k)]);\n"
"    wf = 0.5*(w[IX(i, j, k)] + w[IX(i, j, k + 1)]);\n"
"\n"
"\n"
"    // define the flow rate at the surface\n"
"    Fw = uw * Dy*Dz;\n"
"    Fe = ue * Dy*Dz;\n"
"    Fs = vs * Dx*Dz;\n"
"    Fn = vn * Dx*Dz;\n"
"    Fb = wb * Dx*Dy;\n"
"    Ff = wf * Dx*Dy;\n"
"\n"
"    // define the coefficient for calculation\n"
"    aw[IX(i, j, k)] = max(Fw, 0);\n"
"    ae[IX(i, j, k)] = max(-Fe, 0);\n"
"    as[IX(i, j, k)] = max(Fs, 0);\n"
"    an[IX(i, j, k)] = max(-Fn, 0);\n"
"    ab[IX(i, j, k)] = max(Fb, 0);\n"
"    af[IX(i, j, k)] = max(-Ff, 0);\n"
"    ap0[IX(i, j, k)] = Dx * Dy * Dz / dt;\n"
"    b[IX(i, j, k)] = psi0[IX(i, j, k)] * ap0[IX(i, j, k)];\n"
"\n"
"  } //end of FOR_W_CELL\n"
"}\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl setting diffusion coefficient for T\n"
"/// 6/7/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"\n"
"__kernel void diff_T(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX) {\n"
"  //printf(\"running diff \");\n"
"  //printf(\"running diff \");\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"\n"
"  __global float *psi = &var[TEMP*size];\n"
"  __global float *psi0 = &var[TMP1*size];\n"
"\n"
"  __global float *aw = &var[AW*size];\n"
"  __global float *ae = &var[AE*size];\n"
"  __global float *as = &var[AS*size];\n"
"  __global float *an = &var[AN*size];\n"
"  __global float *af = &var[AF*size];\n"
"  __global float *ab = &var[AB*size];\n"
"  __global float *ap = &var[AP*size];\n"
"  __global float *ap0 = &var[AP0*size];\n"
"  __global float *b = &var[B*size];\n"
"  __global float *gx = &var[GX*size];\n"
"  __global float *x = &var[X*size];\n"
"  __global float *y = &var[Y*size];\n"
"  __global float*z = &var[Z*size];\n"
"  __global float *gy = &var[GY*size];\n"
"  __global float *gz = &var[GZ*size];\n"
"  __global float *pp = &var[PP*size];\n"
"  __global float *Temp = &var[TEMP*size];\n"
"  __global float *flagp = &var[FLAGP*size];\n"
"\n"
"  REAL dxe, dxw, dyn, dys, dzf, dzb, Dx, Dy, Dz;\n"
"  REAL dt = para->mytime.dt, beta = para->prob.beta;\n"
"  REAL Temp_Buoyancy = para->prob.Temp_Buoyancy;\n"
"  REAL gravx = para->prob.gravx, gravy = para->prob.gravy,\n"
"       gravz = para->prob.gravz;\n"
"  REAL kapa;\n"
"  REAL coef_CONSTANT = 120;\n"
"  REAL kapaE, kapaW, kapaN, kapaS, kapaF, kapaB;\n"
"  int i_plus = 0, i_minus = 0, j_plus = 0, j_minus = 0;\n"
"  int k_plus = 0, k_minus = 0;\n"
"\n"
" // FOR_ALL_CELL\n"
" if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax+1) {\n"
"\n"
"    dxe = x[IX(i+1,j,k)] - x[IX(i,j,k)];\n"
"    dxw = x[IX(i,j,k)] - x[IX(i-1,j,k)];\n"
"    dyn = y[IX(i,j+1,k)] - y[IX(i,j,k)];\n"
"    dys = y[IX(i,j,k)] - y[IX(i,j-1,k)];\n"
"    dzf = z[IX(i,j,k+1)] - z[IX(i,j,k)];\n"
"    dzb = z[IX(i,j,k)] - z[IX(i,j,k-1)];\n"
"    Dx = gx[IX(i,j,k)] - gx[IX(i-1,j,k)];\n"
"    Dy = gy[IX(i,j,k)] - gy[IX(i,j-1,k)];\n"
"    Dz = gz[IX(i,j,k)] - gz[IX(i,j,k-1)];\n"
"\n"
"    if (para->prob.tur_model==CHEN) {\n"
"        i_plus = i+1;\n"
"        i_minus = i-1;\n"
"        j_plus = j+1;\n"
"        j_minus = j-1;\n"
"        k_plus = k+1;\n"
"        k_minus = k-1;\n"
"        kapa = nu_t_chen_zero_equ(para, var, &i, &j, &k)+ para->prob.nu;\n"
"        kapaE = nu_t_chen_zero_equ(para, var, &i_plus, &j, &k) + para->prob.nu;\n"
"        kapaW = nu_t_chen_zero_equ(para, var, &i_minus, &j, &k) + para->prob.nu;\n"
"        kapaN = nu_t_chen_zero_equ(para, var, &i, &j_plus, &k) + para->prob.nu;\n"
"        kapaS = nu_t_chen_zero_equ(para, var, &i, &j_minus, &k) + para->prob.nu;\n"
"        kapaF = nu_t_chen_zero_equ(para, var, &i, &j, &k_plus) + para->prob.nu;\n"
"        kapaB = nu_t_chen_zero_equ(para, var, &i, &j, &k_minus) + para->prob.nu;\n"
"        aw[IX(i, j, k)] = 0.5*(kapa + kapaW)*Dy*Dz / dxw;\n"
"        ae[IX(i, j, k)] = 0.5*(kapa + kapaE)*Dy*Dz / dxe;\n"
"        an[IX(i, j, k)] = 0.5*(kapa + kapaN)*Dx*Dz / dyn;\n"
"        as[IX(i, j, k)] = 0.5*(kapa + kapaS)*Dx*Dz / dys;\n"
"        af[IX(i, j, k)] = 0.5*(kapa + kapaF)*Dx*Dy / dzf;\n"
"        ab[IX(i, j, k)] = 0.5*(kapa + kapaB)*Dx*Dy / dzb;\n"
"    }\n"
"\n"
"    else {\n"
"        aw[IX(i,j,k)] = kapa*Dy*Dz/dxw;\n"
"        ae[IX(i,j,k)] = kapa*Dy*Dz/dxe;\n"
"        an[IX(i,j,k)] = kapa*Dx*Dz/dyn;\n"
"        as[IX(i,j,k)] = kapa*Dx*Dz/dys;\n"
"        af[IX(i,j,k)] = kapa*Dx*Dy/dzf;\n"
"        ab[IX(i,j,k)] = kapa*Dx*Dy/dzb;\n"
"    }\n"
"\n"
"    ap0[IX(i,j,k)] = Dx*Dy*Dz/dt;\n"
"    b[IX(i,j,k)] = psi0[IX(i,j,k)]*ap0[IX(i,j,k)];\n"
"\n"
"  } // end of FOR_ALL_CELL\n"
"} // __kernel void diff_T\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl setting advection coefficient for T\n"
"/// 8/7/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void adve_T_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"\n"
"  __global float *psi = &var[TMP1*size];\n"
"  __global float *psi0 = &var[TEMP*size];\n"
"  __global float *aw = &var[AW*size];\n"
"  __global float *ae = &var[AE*size];\n"
"  __global float *as = &var[AS*size];\n"
"  __global float *an = &var[AN*size];\n"
"  __global float *af = &var[AF*size];\n"
"  __global float *ab = &var[AB*size];\n"
"  __global float *ap0 = &var[AP0*size];\n"
"  __global float *b = &var[B*size];\n"
"  __global float *x = &var[X*size];\n"
"  __global float *y = &var[Y*size];\n"
"  __global float *z = &var[Z*size];\n"
"  __global float *gx = &var[GX*size];\n"
"  __global float *gy = &var[GY*size];\n"
"  __global float *gz = &var[GZ*size];\n"
"  __global float *u = &var[VX*size];\n"
"  __global float *v = &var[VY*size];\n"
"  __global float *w = &var[VZ*size];\n"
"\n"
"  REAL dxe, dxw, dyn, dys, dzf, dzb, Dx, Dy, Dz;\n"
"  REAL uw, ue, vs, vn, wb, wf;\n"
"  REAL Fw, Fe, Fs, Fn, Fb, Ff;\n"
"  REAL dt = para->mytime.dt;\n"
"\n"
"   if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax+1) {\n"
"      // define the dimensions\n"
"      Dx = gx[IX(i, j, k)] - gx[IX(i - 1, j, k)];\n"
"      Dy = gy[IX(i, j, k)] - gy[IX(i, j - 1, k)];\n"
"      Dz = gz[IX(i, j, k)] - gz[IX(i, j, k - 1)];\n"
"\n"
"      // define the velocity at the surface\n"
"      uw = u[IX(i - 1, j, k)];\n"
"      ue = u[IX(i, j, k )];\n"
"      vs = v[IX(i, j - 1, k)];\n"
"      vn = v[IX(i, j, k)];\n"
"      wb = w[IX(i, j, k - 1)];\n"
"      wf = w[IX(i, j, k)];\n"
"\n"
"\n"
"      // define the flow rate at the surface\n"
"      Fw = uw * Dy*Dz;\n"
"      Fe = ue * Dy*Dz;\n"
"      Fs = vs * Dx*Dz;\n"
"      Fn = vn * Dx*Dz;\n"
"      Fb = wb * Dx*Dy;\n"
"      Ff = wf * Dx*Dy;\n"
"\n"
"      // define the coefficient for calculation\n"
"      aw[IX(i, j, k)] = max(Fw, 0);\n"
"      ae[IX(i, j, k)] = max(-Fe, 0);\n"
"      as[IX(i, j, k)] = max(Fs, 0);\n"
"      an[IX(i, j, k)] = max(-Fn, 0);\n"
"      ab[IX(i, j, k)] = max(Fb, 0);\n"
"      af[IX(i, j, k)] = max(-Ff, 0);\n"
"      ap0[IX(i, j, k)] = Dx * Dy * Dz / dt;\n"
"      b[IX(i, j, k)] = psi0[IX(i, j, k)] * ap0[IX(i, j, k)];\n"
"\n"
"   }// end of FOR_ALL_CELL\n"
"}\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl of advection for VX\n"
"/// 6/16/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void adve_VX(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int itmax = 20000;\n"
"  int it;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  REAL x_1, y_1, z_1;\n"
"  REAL dt = para->mytime.dt;\n"
"  REAL u0, v0, w0;\n"
"  int  COOD[3], LOC[3];\n"
"  REAL OL[3];\n"
"  int  OC[3];\n"
"\n"
"  // global variables\n"
"  __global REAL *x = &var[X*size], *y = &var[Y*size],  *z = &var[Z*size];\n"
"  __global REAL *gx = &var[GX*size];\n"
"  __global REAL *u = &var[VX*size], *v = &var[VY*size], *w = &var[VZ*size];\n"
"  __global REAL *flagu = &var[FLAGU*size], *flagp = &var[FLAGP*size];\n"
"\n"
"  // Acustomized variables\n"
"  // In advection, VX is used to calcalute new value to update temporal TMP1\n"
"  // Then TMP1 is used in diffusion to update the VX\n"
"  // Therefore in diffusion the order of d and d0 is reversed\n"
"  // note by wei, 6/17/2015\n"
"  // checkpoint: adve_VX()\n"
"\n"
"  __global REAL *d = &var[TMP1*size];\n"
"  __global REAL *d0 = &var[VX*size];\n"
"\n"
"  // FOR_U_CELL and the cell is of fluid type\n"
"  if (i>0 && i<imax && j>0 && j<jmax+1 && k>0 && k<kmax+1 && flagu[IX(i,j,k)] < 0) {\n"
"      u0 = u[IX(i,j,k)];\n"
"    v0 = (REAL) 0.5\n"
"      * ((v[IX(i,  j,k)]+v[IX(i,  j-1,k)])*( x[IX(i+1,j,k)]-gx[IX(i,j,k)])\n"
"        +(v[IX(i+1,j,k)]+v[IX(i+1,j-1,k)])*(gx[IX(i,  j,k)]- x[IX(i,j,k)]))\n"
"      / (x[IX(i+1,j,k)]-x[IX(i,j,k)]);\n"
"    w0 = (REAL) 0.5\n"
"      * ((w[IX(i,  j,k)]+w[IX(i  ,j, k-1)])*( x[IX(i+1,j,k)]-gx[IX(i,j,k)])\n"
"        +(w[IX(i+1,j,k)]+w[IX(i+1,j, k-1)])*(gx[IX(i,  j,k)]- x[IX(i,j,k)]))\n"
"      / (x[IX(i+1,j,k)]-x[IX(i,j,k)]);\n"
"    // Find the location at previous time step\n"
"    OL[X] =gx[IX(i,j,k)] - u0*dt;\n"
"    OL[Y] = y[IX(i,j,k)] - v0*dt;\n"
"    OL[Z] = z[IX(i,j,k)] - w0*dt;\n"
"    // Initialize the coordinates of previous step\n"
"    OC[X] = i;\n"
"    OC[Y] = j;\n"
"    OC[Z] = k; //OC is the trace back coordinates\n"
"    // Initialize the signs for track process\n"
"    // Completed: 0; In process: 1\n"
"    COOD[X] = 1;\n"
"    COOD[Y] = 1;\n"
"    COOD[Z] = 1;\n"
"    // Initialize the signs for recording if the track back hits the boundary\n"
"    // Hit the boundary: 0; Not hit the boundary: 1\n"
"    LOC[X] = 1;\n"
"    LOC[Y] = 1;\n"
"    LOC[Z] = 1;\n"
"    //Initialize the number of iterations\n"
"    it=1;\n"
"\n"
"    // Trace back more if the any of the trace is still in process\n"
"    while(COOD[X]==1 || COOD[Y] ==1 || COOD[Z] ==1)\n"
"    {\n"
"      it++;\n"
"      // If trace in X is in process and donot hit the boundary\n"
"      if(COOD[X]==1 && LOC[X]==1)\n"
"      set_x_location(para, var, flagu, gx, &u0, &i, &j, &k, OL, OC, LOC, COOD);\n"
"      // If trace in Y is in process and donot hit the boundary\n"
"      if(COOD[Y]==1 && LOC[Y]==1)\n"
"      set_y_location(para, var, flagu, y, &v0, &i, &j, &k, OL, OC, LOC, COOD);\n"
"      // If trace in Z is in process and donot hit the boundary\n"
"      if(COOD[Z]==1 && LOC[Z]==1)\n"
"      set_z_location(para, var, flagu, z, &w0, &i, &j, &k, OL, OC, LOC, COOD);\n"
"\n"
"      //if(it>itmax)\n"
"      //{\n"
"      //printf(\"Error: advection.c, can not track the location for VX(%d, %d,%d)\",\n"
"          //i, j, k);\n"
"      //printf(\"after %d iterations. \", it);\n"
"      //}\n"
"    } // End of while() for backward tracing\n"
"\n"
"    // Set the coordinates of previous location if it is as boundary\n"
"    if(u0>0 && LOC[X]==0) OC[X] -=1;\n"
"    if(v0>0 && LOC[Y]==0) OC[Y] -=1;\n"
"    if(w0>0 && LOC[Z]==0) OC[Z] -=1;\n"
"\n"
"    // LOC=1 means that traced back point hits boundary.\n"
"    // When u is less than zero, the traced back point is towards west.\n"
"    // When it hits the boundary, according to the code,\n"
"    // the east cell of west boundary will be given as the traced back location\n"
"    // and the index (OC) is also marching on one cell.\n"
"    // This means that the index and traced back location are on same cell.\n"
"    // That is why the index needs to move backward for one cell\n"
"    // in order to do interpolation.\n"
"    if(u0<0 && LOC[X]==1) OC[X] -=1;\n"
"    if(v0<0 && LOC[Y]==1) OC[Y] -=1;\n"
"    if(w0<0 && LOC[Z]==1) OC[Z] -=1;\n"
"\n"
"        // interpolate\n"
"    x_1 = (OL[X]-gx[IX(OC[X],OC[Y],OC[Z])])\n"
"      / (gx[IX(OC[X]+1,OC[Y],OC[Z])]-gx[IX(OC[X],OC[Y],OC[Z])]);\n"
"    y_1 = (OL[Y]-y[IX(OC[X],OC[Y],OC[Z])])\n"
"      / (y[IX(OC[X],OC[Y]+1,OC[Z])]-y[IX(OC[X],OC[Y],OC[Z])]);\n"
"    z_1 = (OL[Z]-z[IX(OC[X],OC[Y],OC[Z])])\n"
"      / (z[IX(OC[X],OC[Y],OC[Z]+1)]-z[IX(OC[X],OC[Y],OC[Z])]);\n"
"      // checkpoint: adve_VX()\n"
"    d[IX(i,j,k)] = interpolation(para, d0, &x_1, &y_1, &z_1, &OC[X], &OC[Y], &OC[Z]);\n"
"  } //end of FOR_U_CELL\n"
"} //end of kernel adve_VX()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl of advection for VY\n"
"/// 6/16/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void adve_VY(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int it;\n"
"  int itmax = 20000; // Max number of iterations for backward tracing\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  REAL x_1, y_1, z_1;\n"
"  REAL dt = para->mytime.dt;\n"
"  REAL u0, v0, w0;\n"
"\n"
"  int  COOD[3], LOC[3];\n"
"  REAL OL[3];\n"
"  int  OC[3];\n"
"\n"
"  // global variables\n"
"  __global REAL *x = &var[X*size], *y = &var[Y*size],  *z = &var[Z*size];\n"
"  __global REAL *gy = &var[GY*size];\n"
"  __global REAL *u = &var[VX*size], *v = &var[VY*size], *w = &var[VZ*size];\n"
"  __global REAL *flagv = &var[FLAGV*size], *flagp = &var[FLAGP*size];\n"
"\n"
"  // Acustomized variables\n"
"  // In advection, VY is used to calcalute new value to update temporal TMP2\n"
"  // Then TMP2 is used in diffusion to update the VY\n"
"  // Therefore in diffusion the order of d and d0 is reversed\n"
"  // note by wei, 6/17/2015\n"
"  // checkpoint: adve_VY()\n"
"\n"
"  __global REAL *d = &var[TMP2*size];\n"
"  __global REAL *d0 = &var[VY*size];\n"
"\n"
"  //FOR_V_CELL\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax && k>0 && k<kmax+1 && flagv[IX(i,j,k)] < 0) {\n"
"\n"
"    /*-------------------------------------------------------------------------\n"
"    | Step 1: Tracing Back\n"
"    -------------------------------------------------------------------------*/\n"
"    // Get velocities at the location of VY\n"
"    u0 = (REAL) 0.5\n"
"       * ((u[IX(i,j,k)]+u[IX(i-1,j,  k)])*(y [IX(i,j+1,k)]-gy[IX(i,j,k)])\n"
"         +(u[IX(i,j+1,k)]+u[IX(i-1,j+1,k)])*(gy[IX(i,j,  k)]-y[IX(i,j,k)]))\n"
"       / (y[IX(i,j+1,k)]-y[IX(i,j,k)]);\n"
"    v0 = v[IX(i,j,k)];\n"
"    w0 = (REAL) 0.5\n"
"       * ((w[IX(i,j,k)]+w[IX(i,j,k-1)])*(y[IX(i,j+1,k)]-gy[IX(i,j,k)])\n"
"         +(w[IX(i,j+1,k)]+w[IX(i,j+1,k-1)])*(gy[IX(i,j,k)]-y[IX(i,j,k)]))\n"
"       / (y[IX(i,j+1,k)]-y[IX(i,j,k)]);\n"
"    // Find the location at previous time step\n"
"    OL[X] = x[IX(i,j,k)] - u0*dt;\n"
"    OL[Y] = gy[IX(i,j,k)] - v0*dt;\n"
"    OL[Z] = z[IX(i,j,k)] - w0*dt;\n"
"    // Initialize the coordinates of previous step\n"
"    OC[X] = i;\n"
"    OC[Y] = j;\n"
"    OC[Z] = k;\n"
"    // Initialize the signs for track process\n"
"    // Completed: 0; In process: 1\n"
"    COOD[X] = 1;\n"
"    COOD[Y] = 1;\n"
"    COOD[Z] = 1;\n"
"    // Initialize the signs for recording if the track back hits the boundary\n"
"    // Hit the boundary: 0; Not hit the boundary: 1\n"
"    LOC[X] = 1;\n"
"    LOC[Y] = 1;\n"
"    LOC[Z] = 1;\n"
"    //Initialize the number of iterations\n"
"    it=1;\n"
"\n"
"    // Trace back more if the any of the trace is still in process\n"
"    while(COOD[X]==1 || COOD[Y] ==1 || COOD[Z] == 1) {\n"
"      it++;\n"
"      if(COOD[X]==1 && LOC[X]==1)\n"
"        set_x_location(para, var, flagv, x, &u0, &i, &j, &k, OL, OC, LOC, COOD);\n"
"      if(COOD[Y]==1 && LOC[Y]==1)\n"
"        set_y_location(para, var, flagv, gy, &v0, &i, &j, &k, OL, OC, LOC, COOD);\n"
"      if(COOD[Z]==1 && LOC[Z]==1)\n"
"        set_z_location(para, var, flagv, z, &w0, &i, &j, &k, OL, OC, LOC, COOD);\n"
"\n"
"      //if(it>itmax) {\n"
"        //printf(\"Error: advection.c can not track the location for VY(%d, %d,%d)\",\n"
"                //i, j, k);\n"
"        //printf(\"after %d iterations. \", it);\n"
"      //}\n"
"    } // End of while() loop\n"
"\n"
"    // Set the coordinates of previous location if it is as boundary\n"
"    if(u0>=0 && LOC[X]==0) OC[X] -= 1;\n"
"    if(v0>=0 && LOC[Y]==0) OC[Y] -= 1;\n"
"    if(w0>=0 && LOC[Z]==0) OC[Z] -= 1;\n"
"\n"
"    if(u0<0 && LOC[X]==1) OC[X] -= 1;\n"
"    if(v0<0 && LOC[Y]==1) OC[Y] -= 1;\n"
"    if(w0<0 && LOC[Z]==1) OC[Z] -= 1;\n"
"\n"
"    /*-------------------------------------------------------------------------\n"
"    | Interpolating for all variables\n"
"    -------------------------------------------------------------------------*/\n"
"    x_1 = (OL[X]-x[IX(OC[X],OC[Y],OC[Z])])\n"
"        / (x[IX(OC[X]+1,OC[Y],OC[Z])]-x[IX(OC[X],OC[Y],OC[Z])]);\n"
"    y_1 = (OL[Y]-gy[IX(OC[X],OC[Y],OC[Z])])\n"
"        / (gy[IX(OC[X],OC[Y]+1,OC[Z])]-gy[IX(OC[X],OC[Y],OC[Z])]);\n"
"    z_1 = (OL[Z]-z[IX(OC[X],OC[Y],OC[Z])])\n"
"        / (z[IX(OC[X],OC[Y],OC[Z]+1)]-z[IX(OC[X],OC[Y],OC[Z])]);\n"
"    d[IX(i,j,k)] = interpolation(para, d0, &x_1, &y_1, &z_1, &OC[X],&OC[Y],&OC[Z]);\n"
"  } // end of FOR_V_CELL\n"
"} // End of trace_vy()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl of advection for VZ\n"
"/// 6/17/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void adve_VZ(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int it;\n"
"  int itmax = 20000; // Max number of iterations for backward tracing\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  REAL x_1, y_1, z_1;\n"
"  REAL dt = para->mytime.dt;\n"
"  REAL u0, v0, w0;\n"
"\n"
"  int  COOD[3], LOC[3];\n"
"  REAL OL[3];\n"
"  int  OC[3];\n"
"\n"
"  // global variables\n"
"  __global REAL *x = &var[X*size], *y = &var[Y*size],  *z = &var[Z*size];\n"
"  __global REAL *gz = &var[GZ*size];\n"
"  __global REAL *u = &var[VX*size], *v = &var[VY*size], *w = &var[VZ*size];\n"
"  __global REAL *flagw = &var[FLAGW*size], *flagp = &var[FLAGP*size];\n"
"\n"
"  // Acustomized variables\n"
"  // In advection, VZ is used to calcalute new value to update temporal TMP3\n"
"  // Then TMP3 is used in diffusion to update the VZ\n"
"  // Therefore in diffusion the order of d and d0 is reversed\n"
"  // note by wei, 6/17/2015\n"
"  // checkpoint: adve_VZ()\n"
"\n"
"  __global REAL *d = &var[TMP3*size];\n"
"  __global REAL *d0 = &var[VZ*size];\n"
"\n"
"  //FOR_W_CELL\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax && flagw[IX(i,j,k)] < 0) {\n"
"    u0 = (REAL) 0.5\n"
"       * ((u[IX(i,j,k  )]+u[IX(i-1,j,k  )])*(z [IX(i,j,k+1)]-gz[IX(i,j,k)])\n"
"         +(u[IX(i,j,k+1)]+u[IX(i-1,j,k+1)])*(gz[IX(i,j,k  )]- z[IX(i,j,k)]))\n"
"       /  (z[IX(i,j,k+1)]-z[IX(i,j,k)]);\n"
"    v0 = (REAL) 0.5\n"
"       * ((v[IX(i,j,k  )]+v[IX(i,j-1,k  )])*(z [IX(i,j,k+1)]-gz[IX(i,j,k)])\n"
"       +(v[IX(i,j,k+1)]+v[IX(i,j-1,k+1)])*(gz[IX(i,j,k  )]-z [IX(i,j,k)]))\n"
"       /  (z[IX(i,j,k+1)]-z[IX(i,j,k)]);\n"
"    w0 = w[IX(i,j,k)];\n"
"    // Find the location at previous time step\n"
"    OL[X] = x[IX(i,j,k)] - u0*dt;\n"
"    OL[Y] = y[IX(i,j,k)] - v0*dt;\n"
"    OL[Z] = gz[IX(i,j,k)] - w0*dt;\n"
"    // Initialize the coordinates of previous step\n"
"    OC[X] = i;\n"
"    OC[Y] = j;\n"
"    OC[Z] = k;\n"
"    // Initialize the signs for track process\n"
"    // Completed: 0; In process: 1\n"
"    COOD[X] = 1;\n"
"    COOD[Y] = 1;\n"
"    COOD[Z] = 1;\n"
"    // Initialize the signs for recording if the track back hits the boundary\n"
"    // Hit the boundary: 0; Not hit the boundary: 1\n"
"    LOC[X] = 1;\n"
"    LOC[Y] = 1;\n"
"    LOC[Z] = 1;\n"
"    //Initialize the number of iterations\n"
"    it=1;\n"
"\n"
"    // Trace back more if the any of the trace is still in process\n"
"    while(COOD[X]==1 || COOD[Y] ==1 || COOD[Z] == 1) {\n"
"      it++;\n"
"      if(COOD[X]==1 && LOC[X]==1)\n"
"        set_x_location(para, var, flagw, x, &u0, &i, &j, &k, OL, OC, LOC, COOD);\n"
"      if(COOD[Y]==1 && LOC[Y]==1)\n"
"        set_y_location(para, var, flagw, y, &v0, &i, &j, &k, OL, OC, LOC, COOD);\n"
"      if(COOD[Z]==1 && LOC[Z]==1)\n"
"        set_z_location(para, var, flagw, gz, &w0, &i, &j, &k, OL, OC, LOC, COOD);\n"
"\n"
"      //if(it>itmax) {\n"
"        //printf(\"Error: advection.c can not track the location for VZ(%d, %d,%d)\",\n"
"                //i, j, k);\n"
"        //printf(\"after %d iterations. \", it);\n"
"      //}\n"
"    } // End of while() loop\n"
"\n"
"    // Set the coordinates of previous location if it is as boundary\n"
"    if(u0>=0 && LOC[X] == 0) OC[X] -=1;\n"
"    if(v0>=0 && LOC[Y] == 0) OC[Y] -=1;\n"
"    if(w0>=0 && LOC[Z] == 0) OC[Z] -=1;\n"
"\n"
"    if(u0<0 && LOC[X]==1) OC[X] -=1;\n"
"    if(v0<0 && LOC[Y]==1) OC[Y] -=1;\n"
"    if(w0<0 && LOC[Z]==1) OC[Z] -=1;\n"
"\n"
"    /*-------------------------------------------------------------------------\n"
"    | Interpolating for all variables\n"
"    -------------------------------------------------------------------------*/\n"
"    x_1 = (OL[X]- x[IX(OC[X],OC[Y],OC[Z])])\n"
"        / ( x[IX(OC[X]+1,OC[Y],   OC[Z]  )]- x[IX(OC[X],OC[Y],OC[Z])]);\n"
"    y_1 = (OL[Y]- y[IX(OC[X],OC[Y],OC[Z])])\n"
"        / ( y[IX(OC[X],  OC[Y]+1, OC[Z]  )]- y[IX(OC[X],OC[Y],OC[Z])]);\n"
"    z_1 = (OL[Z]-gz[IX(OC[X],OC[Y],OC[Z])])\n"
"        / (gz[IX(OC[X],  OC[Y],   OC[Z]+1)]-gz[IX(OC[X],OC[Y],OC[Z])]);\n"
"     d[IX(i,j,k)] = interpolation(para, d0, &x_1, &y_1, &z_1, &OC[X], &OC[Y], &OC[Z]);\n"
"  }// end of FOR_W_CELL\n"
"\n"
"}// end of adve_VZ()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl of advection for T\n"
"/// 6/17/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void adve_T(__global PARA_DATA_SIMP *para, __global REAL *var, __global  int *BINDEX) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int it;\n"
"  int itmax = 20000; // Max number of iterations for backward tracing\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  REAL x_1, y_1, z_1;\n"
"  REAL dt = para->mytime.dt;\n"
"  REAL u0, v0, w0;\n"
"\n"
"  int  COOD[3], LOC[3];\n"
"  REAL OL[3];\n"
"  int  OC[3];\n"
"\n"
"  // global variables\n"
"  __global REAL *x = &var[X*size], *y = &var[Y*size],  *z = &var[Z*size];\n"
"  __global REAL *gz = &var[GZ*size];\n"
"  __global REAL *u = &var[VX*size], *v = &var[VY*size], *w = &var[VZ*size];\n"
"  __global REAL *flagp = &var[FLAGP*size];\n"
"\n"
"  // Acustomized variables\n"
"  // In advection, TEMP is used to calcalute new value to update temporal TMP1\n"
"  // Then TMP3 is used in diffusion to update the TEMP\n"
"  // Therefore in diffusion the order of d and d0 is reversed\n"
"  // note by wei, 6/17/2015\n"
"  // checkpoint: adve_T()\n"
"\n"
"  __global REAL *d = &var[TMP1*size];\n"
"  __global REAL *d0 = &var[TEMP*size];\n"
"\n"
"  //FOR_EACH_CELL\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax+1 && flagp[IX(i,j,k)] < 0) {\n"
"    u0 = (REAL) 0.5 * (u[IX(i,j,k)]+u[IX(i-1,j,k  )]);\n"
"    v0 = (REAL) 0.5 * (v[IX(i,j,k)]+v[IX(i,j-1,k  )]);\n"
"    w0 = (REAL) 0.5 * (w[IX(i,j,k)]+w[IX(i,j  ,k-1)]);\n"
"    // Find the location at previous time step\n"
"    OL[X] = x[IX(i,j,k)] - u0*dt;\n"
"    OL[Y] = y[IX(i,j,k)] - v0*dt;\n"
"    OL[Z] = z[IX(i,j,k)] - w0*dt;\n"
"    // Initialize the coordinates of previous step\n"
"    OC[X] = i;\n"
"    OC[Y] = j;\n"
"    OC[Z] = k;\n"
"    // Initialize the signs for tracing process\n"
"    // Completed: 0; In process: 1\n"
"    COOD[X] = 1;\n"
"    COOD[Y] = 1;\n"
"    COOD[Z] = 1;\n"
"    // Initialize the flags for recording if the tracing back hits the boundary\n"
"    // Hit the boundary: 0; Not hit the boundary: 1\n"
"    LOC[X] = 1;\n"
"    LOC[Y] = 1;\n"
"    LOC[Z] = 1;\n"
"    //Initialize the number of iterations\n"
"    it=1;\n"
"\n"
"    // Trace back more if the any of the trace is still in process\n"
"    while(COOD[X]==1 || COOD[Y] ==1 || COOD[Z] == 1) {\n"
"      it++;\n"
"      // If trace in X is in process and donot hit the boundary\n"
"      if(COOD[X]==1 && LOC[X]==1)\n"
"        set_x_location(para, var, flagp, x, &u0, &i, &j, &k, OL, OC, LOC, COOD);\n"
"      // If trace in Y is in process and donot hit the boundary\n"
"      if(COOD[Y]==1 && LOC[Y]==1)\n"
"        set_y_location(para, var, flagp, y, &v0, &i, &j, &k, OL, OC, LOC, COOD);\n"
"      // If trace in Z is in process and donot hit the boundary\n"
"      if(COOD[Z]==1 && LOC[Z]==1)\n"
"        set_z_location(para, var, flagp, z, &w0, &i, &j, &k, OL, OC, LOC, COOD);\n"
"      //if(it>itmax) {\n"
"        //printf(\"trace_scalar(): Could not track the location for scalar \"\n"
"          //\"variable %d at cell(%d, %d,%d) after %d iterations\",\n"
"          //TEMP, i, j, k, it);\n"
"      //}\n"
"    } // End of while() for backward tracing\n"
"\n"
"    // Set the coordinates of previous location if it is as boundary\n"
"    if(u0>=0 && LOC[X]==0) OC[X] -=1;\n"
"    if(v0>=0 && LOC[Y]==0) OC[Y] -=1;\n"
"    if(w0>=0 && LOC[Z]==0) OC[Z] -=1;\n"
"\n"
"    if(u0<0 && LOC[X]==1) OC[X] -=1;\n"
"    if(v0<0 && LOC[Y]==1) OC[Y] -=1;\n"
"    if(w0<0 && LOC[Z]==1) OC[Z] -=1;\n"
"\n"
"    //Store the local minimum and maximum values\n"
"    //var[LOCMIN][IX(i,j,k)]=check_min(para, d0, OC[X], OC[Y], OC[Z]);\n"
"    //var[LOCMAX][IX(i,j,k)]=check_max(para, d0, OC[X], OC[Y], OC[Z]);\n"
"\n"
"    /*-------------------------------------------------------------------------\n"
"    | Interpolate\n"
"    -------------------------------------------------------------------------*/\n"
"    x_1 = (OL[X]- x[IX(OC[X],OC[Y],OC[Z])])\n"
"        / ( x[IX(OC[X]+1,OC[Y],   OC[Z]  )] - x[IX(OC[X],OC[Y],OC[Z])]);\n"
"    y_1 = (OL[Y]- y[IX(OC[X],OC[Y],OC[Z])])\n"
"        / ( y[IX(OC[X],  OC[Y]+1, OC[Z]  )] - y[IX(OC[X],OC[Y],OC[Z])]);\n"
"    z_1 = (OL[Z]- z[IX(OC[X],OC[Y],OC[Z])])\n"
"        / ( z[IX(OC[X],  OC[Y],   OC[Z]+1)] - z[IX(OC[X],OC[Y],OC[Z])]);\n"
"    d[IX(i,j,k)] = interpolation(para, d0, &x_1, &y_1, &z_1, &OC[X], &OC[Y], &OC[Z]);\n"
"\n"
"  } //end of FOR_EACH_CELL\n"
"} //end of adve_T()\n"
"\n"
"__kernel void project(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int bar;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  REAL dt= para->mytime.dt;\n"
"  __global REAL *x = &var[X*size], *y = &var[Y*size], *z = &var[Z*size];\n"
"  __global REAL *gx = &var[GX*size], *gy = &var[GY*size], *gz = &var[GZ*size];\n"
"  __global REAL *u = &var[VX*size], *v = &var[VY*size], *w = &var[VZ*size];\n"
"  __global REAL *p = &var[IP*size], *b = &var[B*size], *ap = &var[AP*size], *ab = &var[AB*size], *af = &var[AF*size];\n"
"  __global REAL *ae = &var[AE*size], *aw = &var[AW*size], *an = &var[AN*size], *as = &var[AS*size];\n"
"  REAL dxe,dxw, dyn,dys,dzf,dzb,Dx,Dy,Dz;\n"
"  __global REAL *flagu = &var[FLAGU*size],*flagv = &var[FLAGV*size],*flagw = &var[FLAGW*size],*flagp = &var[FLAGP*size];\n"
"\n"
"  /****************************************************************************\n"
"  | Calculate all coefficients\n"
"  ****************************************************************************/\n"
"  //FOR_EACH_CELL\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax+1) {\n"
"    dxe =  x[IX(i+1,j,  k)]   -  x[IX(i,  j,  k)];\n"
"    dxw =  x[IX(i,  j,  k)]   -  x[IX(i-1,j,  k)];\n"
"    dyn =  y[IX(i,  j+1,k)]   -  y[IX(i,  j,  k)];\n"
"    dys =  y[IX(i,  j,  k)]   -  y[IX(i,  j-1,k)];\n"
"    dzf =  z[IX(i,  j,  k+1)] -  z[IX(i,  j,  k)];\n"
"    dzb =  z[IX(i,  j,  k)]   -  z[IX(i,  j,  k-1)];\n"
"    Dx  = gx[IX(i,  j,  k)]   - gx[IX(i-1,j,  k)];\n"
"    Dy  = gy[IX(i,  j,  k)]   - gy[IX(i,  j-1,k)];\n"
"    Dz  = gz[IX(i,  j,  k)]   - gz[IX(i,  j,  k-1)];\n"
"\n"
"    ae[IX(i,j,k)] = Dy*Dz/dxe;\n"
"    aw[IX(i,j,k)] = Dy*Dz/dxw;\n"
"    an[IX(i,j,k)] = Dx*Dz/dyn;\n"
"    as[IX(i,j,k)] = Dx*Dz/dys;\n"
"    af[IX(i,j,k)] = Dx*Dy/dzf;\n"
"    ab[IX(i,j,k)] = Dx*Dy/dzb;\n"
"    b[IX(i,j,k)] = Dx*Dy*Dz/dt*((u[IX(i-1,j,k)]-u[IX(i,j,k)])/Dx\n"
"                 + (v[IX(i,j-1,k)]-v[IX(i,j,k)])/Dy\n"
"                 + (w[IX(i,j,k-1)]-w[IX(i,j,k)])/Dz);\n"
"\n"
"\n"
"    ap[IX(i,j,k)] = ae[IX(i,j,k)] + aw[IX(i,j,k)] + as[IX(i,j,k)] + an[IX(i,j,k)]\n"
"                  + af[IX(i,j,k)] + ab[IX(i,j,k)];\n"
"   }// end of if\n"
"} //end of project()\n"
"\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl of projection\n"
"/// 6/17/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void project_velo_corr(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int bar;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  REAL dt= para->mytime.dt;\n"
"  __global REAL *x = &var[X*size], *y = &var[Y*size], *z = &var[Z*size];\n"
"  __global REAL *u = &var[VX*size], *v = &var[VY*size], *w = &var[VZ*size];\n"
"  __global REAL *p = &var[IP*size];\n"
"  __global REAL *flagu = &var[FLAGU*size],*flagv = &var[FLAGV*size],*flagw = &var[FLAGW*size],*flagp = &var[FLAGP*size];\n"
"\n"
"  /****************************************************************************\n"
"  | Correct the velocity\n"
"  ****************************************************************************/\n"
"  //FOR_U_CELL\n"
"  if (i>0 && i<imax && j>0 && j<jmax+1 && k>0 && k<kmax+1 && flagu[IX(i,j,k)] < 0) {\n"
"    u[IX(i,j,k)] = u[IX(i,j,k)] - dt*(p[IX(i+1,j,k)]-p[IX(i,j,k)]) / (x[IX(i+1,j,k)]-x[IX(i,j,k)]);\n"
"  }\n"
"\n"
"  //FOR_V_CELL\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax && k>0 && k<kmax+1 && flagv[IX(i,j,k)] < 0) {\n"
"    v[IX(i,j,k)] = v[IX(i,j,k)] - dt*(p[IX(i,j+1,k)]-p[IX(i,j,k)]) / (y[IX(i,j+1,k)]-y[IX(i,j,k)]);\n"
"  }\n"
"\n"
"  //FOR_W_CELL\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax && flagw[IX(i,j,k)] < 0) {\n"
"    w[IX(i,j,k)] = w[IX(i,j,k)] - dt*(p[IX(i,j,k+1)]-p[IX(i,j,k)]) / (z[IX(i,j,k+1)]-z[IX(i,j,k)]);\n"
"  }\n"
"} // End of project_velo_corr( )\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl solving linear equation set\n"
"/// 6/7/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void Ax_BSolver(__global PARA_DATA_SIMP *para, __global REAL *var,__global int *index, __global int *WF)\n"
"{\n"
"\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int imax = para->geom.imax, jmax= para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
;


const char source_str3[] =
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"\n"
"  __global REAL *as = &var[AS*size], *aw = &var[AW*size], *ae = &var[AE*size], *an = &var[AN*size];\n"
"  __global REAL *ap = &var[AP*size], *af = &var[AF*size], *ab = &var[AB*size], *b = &var[B*size];\n"
"  __global REAL *flag;\n"
"  __global float *x;\n"
"\n"
"  // set the variables\n"
"  //wei tian added\n"
"  //6/16/2015\n"
"  if (index[0] == VX) {\n"
"    flag = &var[FLAGU*size];\n"
"    if (WF[0] == 0) {\n"
"        x = &var[TMP1*size];\n"
"    }\n"
"    else{\n"
"        x = &var[VX*size];\n"
"    }\n"
"  }// end of if\n"
"  else if  (index[0] == VY) {\n"
"    flag = &var[FLAGV*size];\n"
"    if (WF[0] == 0) {\n"
"        x = &var[TMP2*size];\n"
"    }\n"
"    else{\n"
"        x = &var[VY*size];\n"
"    }\n"
"  }// end of else if\n"
"  else if  (index[0] == VZ) {\n"
"    flag = &var[FLAGW*size];\n"
"    if (WF[0] == 0) {\n"
"        x = &var[TMP3*size];\n"
"    }\n"
"    else{\n"
"        x = &var[VZ*size];\n"
"    }\n"
"  }// end of else if\n"
"  else if  (index[0] == TEMP) {\n"
"    flag = &var[FLAGP*size];\n"
"    if (WF[0] == 0) {\n"
"        x = &var[TMP1*size];\n"
"    }\n"
"    else{\n"
"        x = &var[TEMP*size];\n"
"    }\n"
"  }// end of else if\n"
"\n"
"  // jacobian solver\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax+1 && flag[IX(i,j,k)] < 0) {\n"
"     // var[TMP4] are newly created exclusively for jacobian solver\n"
"  var[TMP4*size+IX(i,j,k)] = ( ae[IX(i,j,k)]*x[IX(i+1,j,k)]\n"
"             + aw[IX(i,j,k)]*x[IX(i-1,j,k)]\n"
"             + an[IX(i,j,k)]*x[IX(i,j+1,k)]\n"
"             + as[IX(i,j,k)]*x[IX(i,j-1,k)]\n"
"             + af[IX(i,j,k)]*x[IX(i,j,k+1)]\n"
"             + ab[IX(i,j,k)]*x[IX(i,j,k-1)]\n"
"             + b[IX(i,j,k)] ) / ap[IX(i,j,k)];\n"
"\n"
"  } // end of if\n"
"} // end of kernel Ax_BSolver()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// update results for jacobian solver\n"
"/// 29/9/2015\n"
"/// wei tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void Ax_BSolver_upd(__global PARA_DATA_SIMP *para, __global REAL *var,__global int *index, __global int *WF)\n"
"{\n"
"\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int imax = para->geom.imax, jmax= para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"\n"
"  __global REAL *as = &var[AS*size], *aw = &var[AW*size], *ae = &var[AE*size], *an = &var[AN*size];\n"
"  __global REAL *ap = &var[AP*size], *af = &var[AF*size], *ab = &var[AB*size], *b = &var[B*size];\n"
"  __global REAL *flag;\n"
"  __global float *x;\n"
"\n"
"  // set the variables\n"
"  //wei tian added\n"
"  //6/16/2015\n"
"  if (index[0] == VX) {\n"
"    flag = &var[FLAGU*size];\n"
"    if (WF[0] == 0) {\n"
"        x = &var[TMP1*size];\n"
"    }\n"
"    else{\n"
"        x = &var[VX*size];\n"
"    }\n"
"  }// end of if\n"
"  else if  (index[0] == VY) {\n"
"    flag = &var[FLAGV*size];\n"
"    if (WF[0] == 0) {\n"
"        x = &var[TMP2*size];\n"
"    }\n"
"    else{\n"
"        x = &var[VY*size];\n"
"    }\n"
"  }// end of else if\n"
"  else if  (index[0] == VZ) {\n"
"    flag = &var[FLAGW*size];\n"
"    if (WF[0] == 0) {\n"
"        x = &var[TMP3*size];\n"
"    }\n"
"    else{\n"
"        x = &var[VZ*size];\n"
"    }\n"
"  }// end of else if\n"
"  else if  (index[0] == TEMP) {\n"
"    flag = &var[FLAGP*size];\n"
"    if (WF[0] == 0) {\n"
"        x = &var[TMP1*size];\n"
"    }\n"
"    else{\n"
"        x = &var[TEMP*size];\n"
"    }\n"
"  }// end of else if\n"
"\n"
"  // jacobian solver\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax+1 && flag[IX(i,j,k)] < 0) {\n"
"     // var[TMP4] are newly created exclusively for jacobian solver\n"
"   x[IX(i,j,k)] =  var[TMP4*size+IX(i,j,k)];\n"
"  } // end of if\n"
"} // end of kernel Ax_BSolver_upd()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl solving linear equation set especially for pressure\n"
"/// 6/17/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void Ax_BSolver_P(__global PARA_DATA_SIMP *para, __global REAL *var)\n"
"{\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"\n"
"  //printf(\"Ax_Solver: now solving [%d,%d,%d] \",i, j, k);\n"
"\n"
"  int imax = para->geom.imax, jmax= para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  int it=0;\n"
"\n"
"  __global REAL *as = &var[AS*size], *aw = &var[AW*size], *ae = &var[AE*size], *an = &var[AN*size];\n"
"  __global REAL *ap = &var[AP*size], *af = &var[AF*size], *ab = &var[AB*size], *b = &var[B*size];\n"
"  __global REAL *flag = &var[FLAGP*size];\n"
"  __global float *x = &var[IP*size];\n"
"\n"
"  // jacobian solver\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax+1 && flag[IX(i,j,k)] < 0) {\n"
"  //printf(\"%d: the cell calc is [%d, %d, %d] \",it, i, j,k);\n"
"  var[TMP4*size+IX(i,j,k)] = ( ae[IX(i,j,k)]*x[IX(i+1,j,k)]\n"
"             + aw[IX(i,j,k)]*x[IX(i-1,j,k)]\n"
"             + an[IX(i,j,k)]*x[IX(i,j+1,k)]\n"
"             + as[IX(i,j,k)]*x[IX(i,j-1,k)]\n"
"             + af[IX(i,j,k)]*x[IX(i,j,k+1)]\n"
"             + ab[IX(i,j,k)]*x[IX(i,j,k-1)]\n"
"             + b[IX(i,j,k)] ) / ap[IX(i,j,k)];\n"
"  } // end of if\n"
"} // end of kernel Ax_BSolver_P()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kenerl solving linear equation set especially for pressure\n"
"/// 6/17/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void Ax_BSolver_P_upd(__global PARA_DATA_SIMP *para, __global REAL *var)\n"
"{\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"\n"
"  //printf(\"Ax_Solver: now solving [%d,%d,%d] \",i, j, k);\n"
"\n"
"  int imax = para->geom.imax, jmax= para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  int it=0;\n"
"\n"
"  __global REAL *as = &var[AS*size], *aw = &var[AW*size], *ae = &var[AE*size], *an = &var[AN*size];\n"
"  __global REAL *ap = &var[AP*size], *af = &var[AF*size], *ab = &var[AB*size], *b = &var[B*size];\n"
"  __global REAL *flag = &var[FLAGP*size];\n"
"  __global float *x = &var[IP*size];\n"
"\n"
"  // jacobian solver\n"
"  if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax+1 && flag[IX(i,j,k)] < 0) {\n"
"     x[IX(i,j,k)] = var[TMP4*size+IX(i,j,k)];\n"
"  } // end of if\n"
"} // end of kernel Ax_BSolver_P_upd()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// set boundary conditions for temperature\n"
"/// 6/7/2015\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void set_bnd_T(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *WF, __global int *BINDEX) {\n"
"    int it = get_global_id(0);\n"
"  int i, j, k;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"  __global REAL *aw = &var[AW*size], *ae = &var[AE*size], *as = &var[AS*size], *an = &var[AN*size];\n"
"  __global REAL *af = &var[AF*size], *ab = &var[AB*size], *b = &var[B*size],\n"
"    *qflux = &var[QFLUX*size], *qfluxbc = &var[QFLUXBC*size];\n"
"  __global REAL *flagp = &var[FLAGP*size];\n"
"  __global REAL *psi;\n"
"  REAL axy, ayz, azx;\n"
"  REAL h ; // fixme, other flow needs to be remodelled\n"
"  REAL rhoCp_1 = 1 / (para->prob.rho * para->prob.Cp);\n"
"  REAL D;\n"
"  int tmp1=0;\n"
"\n"
"  // get the index\n"
"  i = BINDEX[0*size+it];\n"
"    j = BINDEX[1*size+it];\n"
"    k = BINDEX[2*size+it];\n"
"\n"
"  // if Advection\n"
"  if (WF[0] == 0) {\n"
"    psi = &var[TMP1*size];\n"
"  }\n"
"  // else if diffusion\n"
"  else if (WF[0] == 1) {\n"
"    psi = &var[TEMP*size];\n"
"  }\n"
"\n"
"  axy = area_xy(para, var, &i, &j, &k);\n"
"  ayz = area_yz(para, var, &i, &j, &k);\n"
"  azx = area_zx(para, var, &i, &j, &k);\n"
"\n"
"  /*-------------------------------------------------------------------------\n"
"  | Inlet boundary\n"
"  | 0: Inlet, -1: Fluid,  1: Solid Wall or Block, 2: Outlet\n"
"  -------------------------------------------------------------------------*/\n"
"  if (flagp[IX(i, j, k)] == INLET || flagp[IX(i,j,k)] == RACK_OUTLET) psi[IX(i, j, k)] = var[TEMPBC*size + IX(i, j, k)];\n"
"\n"
"  /*-------------------------------------------------------------------------\n"
"  | Solid wall or block\n"
"  -------------------------------------------------------------------------*/\n"
"  if (flagp[IX(i, j, k)] == SOLID) {\n"
"    /*......................................................................\n"
"    | Constant temperature\n"
"    ......................................................................*/\n"
"    if (BINDEX[3*size + it] == 1) {\n"
"      psi[IX(i, j, k)] = var[TEMPBC*size + IX(i, j, k)];\n"
"\n"
"      // West boundary wall and eastern neighbor cell is fluid\n"
"      if (i == 0) {\n"
"        if (flagp[IX(i + 1, j, k)] == FLUID) {\n"
"            tmp1 = i + 1;\n"
"          D = 0.5f * length_x(para, var, &tmp1, &j, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          aw[IX(i + 1, j, k)] = h * rhoCp_1 * ayz;\n"
"          qflux[IX(i, j, k)] = h * (psi[IX(i + 1, j, k)] - psi[IX(i, j, k)]);\n"
"        }\n"
"      } // End of if(i==0)\n"
"      // East boundary wall and western neighbor cell is fluid\n"
"      else if (i == imax + 1) {\n"
"        if (flagp[IX(i - 1, j, k)] == FLUID) {\n"
"            tmp1 = i -1;\n"
"          D = 0.5f * length_x(para, var, &tmp1, &j, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          ae[IX(i - 1, j, k)] = h * rhoCp_1 * ayz;\n"
"          qflux[IX(i, j, k)] = h * (psi[IX(i - 1, j, k)] - psi[IX(i, j, k)]);\n"
"        }\n"
"      } // End of else if(i==imax+1)\n"
"      // Between West and East\n"
"      else {\n"
"        // Eastern neighbor cell is fluid\n"
"        if (flagp[IX(i + 1, j, k)] == FLUID) {\n"
"            tmp1 = i + 1;\n"
"          D = 0.5f * length_x(para, var, &tmp1, &j, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          aw[IX(i + 1, j, k)] = h * rhoCp_1 * ayz;\n"
"          qflux[IX(i, j, k)] = h * (psi[IX(i + 1, j, k)] - psi[IX(i, j, k)]);\n"
"        }\n"
"        // Western neighbor cell is fluid\n"
"        if (flagp[IX(i - 1, j, k)] == FLUID) {\n"
"            tmp1 = i + 1;\n"
"          D = 0.5f * length_x(para, var, &tmp1, &j, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          ae[IX(i - 1, j, k)] = h * rhoCp_1 * ayz;\n"
"          qflux[IX(i, j, k)] = h * (psi[IX(i - 1, j, k)] - psi[IX(i, j, k)]);\n"
"        }\n"
"      } // End of 0<i<imax+1\n"
"      // South wall boundary and northern neighbor is fluid\n"
"      if (j == 0) {\n"
"        if (flagp[IX(i, j + 1, k)] == FLUID) {\n"
"            tmp1 = j + 1;\n"
"          D = 0.5f * length_y(para, var, &i, &tmp1, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          as[IX(i, j + 1, k)] = h * rhoCp_1 * azx;\n"
"          qflux[IX(i, j, k)] = h * (psi[IX(i, j + 1, k)] - psi[IX(i, j, k)]);\n"
"        }\n"
"      }\n"
"      // North wall boundary and southern neighbor is fluid\n"
"      else if (j == jmax + 1) {\n"
"        if (flagp[IX(i, j - 1, k)] == FLUID) {\n"
"            tmp1 = j - 1;\n"
"          D = 0.5f * length_y(para, var, &i, &tmp1, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          an[IX(i, j - 1, k)] = h * rhoCp_1 * azx;\n"
"          qflux[IX(i, j, k)] = h * (psi[IX(i, j - 1, k)] - psi[IX(i, j, k)]);\n"
"        }\n"
"      }\n"
"      // Between South and North\n"
"      else {\n"
"        // Southern neighbor is fluid\n"
"        if (flagp[IX(i, j - 1, k)] == FLUID) {\n"
"            tmp1 = j - 1;\n"
"          D = 0.5f * length_y(para, var, &i, &tmp1, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          an[IX(i, j - 1, k)] = h * rhoCp_1 * azx;\n"
"          qflux[IX(i, j, k)] = h * (psi[IX(i, j - 1, k)] - psi[IX(i, j, k)]);\n"
"        }\n"
"        // Northern neighbor is fluid\n"
"        if (flagp[IX(i, j + 1, k)] == FLUID) {\n"
"            tmp1 = j + 1;\n"
"          D = 0.5f * length_y(para, var, &i, &tmp1, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          as[IX(i, j + 1, k)] = h * rhoCp_1 * azx;\n"
"          qflux[IX(i, j, k)] = h * (psi[IX(i, j + 1, k)] - psi[IX(i, j, k)]);\n"
"        }\n"
"      }\n"
"      // Floor and ceiling neighbor is fluid\n"
"      if (k == 0) {\n"
"        if (flagp[IX(i, j, k + 1)] == FLUID) {\n"
"            tmp1 = k + 1;\n"
"          D = 0.5f * length_z(para, var, &i, &j, &tmp1);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          ab[IX(i, j, k + 1)] = h * rhoCp_1 * axy;\n"
"          qflux[IX(i, j, k)] = h * (psi[IX(i, j, k + 1)] - psi[IX(i, j, k)]);\n"
"        }\n"
"      }\n"
"      // Ceiling and floor neighbor is fluid\n"
"      else if (k == kmax + 1) {\n"
"        if (flagp[IX(i, j, k - 1)] == FLUID) {\n"
"            tmp1 = k + 1;\n"
"          D = 0.5f * length_z(para, var, &i, &j, &tmp1);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          af[IX(i, j, k - 1)] = h * rhoCp_1 * axy;\n"
"          qflux[IX(i, j, k)] = h * (psi[IX(i, j, k - 1)] - psi[IX(i, j, k)]);\n"
"        }\n"
"      }\n"
"      // Between Floor and Ceiling\n"
"      else {\n"
"        // Ceiling neighbor is fluid\n"
"        if (flagp[IX(i, j, k + 1)] == FLUID) {\n"
"            tmp1 = k + 1;\n"
"          D = 0.5f * length_z(para, var, &i, &j, &tmp1);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          ab[IX(i, j, k + 1)] = h * rhoCp_1 * axy;\n"
"          qflux[IX(i, j, k)] = h * (psi[IX(i, j, k + 1)] - psi[IX(i, j, k)]);\n"
"        }\n"
"        // Floor neighbor is fluid\n"
"        if (flagp[IX(i, j, k - 1)] == FLUID) {\n"
"            tmp1 = k - 1;\n"
"          D = 0.5f * length_z(para, var, &i, &j, &tmp1);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          af[IX(i, j, k - 1)] = h * rhoCp_1 * axy;\n"
"          qflux[IX(i, j, k)] = h * (psi[IX(i, j, k - 1)] - psi[IX(i, j, k)]);\n"
"        }\n"
"      }\n"
"    } // End of constant temperature wall\n"
"    /*.......................................................................\n"
"    | Constant heat flux\n"
"    .......................................................................*/\n"
"    if (BINDEX[3*size + it] == 0) {\n"
"      // West wall boundary and eastern neighbor is fluid\n"
"      if (i == 0) {\n"
"        if (flagp[IX(i + 1, j, k)] == FLUID) {\n"
"          aw[IX(i + 1, j, k)] = 0;\n"
"          tmp1 = i + 1;\n"
"          D = 0.5f * length_z(para, var, &tmp1, &j, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          b[IX(i + 1, j, k)] += rhoCp_1 * qfluxbc[IX(i, j, k)] * ayz;\n"
"          // get the temperature of solid surface\n"
"          psi[IX(i, j, k)] = qfluxbc[IX(i, j, k)] / h + psi[IX(i + 1, j, k)];\n"
"        }\n"
"      } // End of if(i==0)\n"
"      // East wall boundary and western neighbor is fluid\n"
"      else if (i == imax + 1) {\n"
"        if (flagp[IX(i - 1, j, k)] == FLUID) {\n"
"          ae[IX(i - 1, j, k)] = 0;\n"
"          tmp1 = i - 1;\n"
"          D = 0.5f * length_z(para, var, &tmp1, &j, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          b[IX(i - 1, j, k)] += rhoCp_1 * qfluxbc[IX(i, j, k)] * ayz;\n"
"          // get the temperature of solid surface\n"
"          psi[IX(i, j, k)] = qfluxbc[IX(i, j, k)] / h + psi[IX(i - 1, j, k)];\n"
"        }\n"
"      } // End of else if(i==imax+1)\n"
"      // Between West and East\n"
"      else {\n"
"        // Eastern neighbor is fluid\n"
"        if (flagp[IX(i + 1, j, k)] == FLUID) {\n"
"          aw[IX(i + 1, j, k)] = 0;\n"
"          tmp1 = i + 1;\n"
"          D = 0.5f * length_z(para, var, &tmp1, &j, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          b[IX(i + 1, j, k)] += rhoCp_1 * qfluxbc[IX(i, j, k)] * ayz;\n"
"          // get the temperature of solid surface\n"
"          psi[IX(i, j, k)] = qfluxbc[IX(i, j, k)] / h + psi[IX(i + 1, j, k)];\n"
"        }\n"
"        // Western neighbor is fluid\n"
"        if (flagp[IX(i - 1, j, k)] == FLUID) {\n"
"          ae[IX(i - 1, j, k)] = 0;\n"
"          tmp1 = i - 1;\n"
"          D = 0.5f * length_z(para, var, &tmp1, &j, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          b[IX(i - 1, j, k)] += rhoCp_1 * qfluxbc[IX(i, j, k)] * ayz;\n"
"          // get the temperature of solid surface\n"
"          psi[IX(i, j, k)] = qfluxbc[IX(i, j, k)] / h + psi[IX(i - 1, j, k)];\n"
"        }\n"
"      } // End of else\n"
"      // South wall boundary and northern neighbor is fluid\n"
"      if (j == 0) {\n"
"        if (flagp[IX(i, j + 1, k)] == FLUID) {\n"
"          as[IX(i, j + 1, k)] = 0;\n"
"          tmp1 = j + 1;\n"
"          D = 0.5f * length_z(para, var, &i, &tmp1, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          b[IX(i, j + 1, k)] += rhoCp_1 * qfluxbc[IX(i, j, k)] * azx;\n"
"          // get the temperature of solid surface\n"
"          psi[IX(i, j, k)] = qfluxbc[IX(i, j, k)] / h + psi[IX(i, j + 1, k)];\n"
"        }\n"
"      }\n"
"      // North wall boundary and southern neighbor is fluid\n"
"      else if (j == jmax + 1) {\n"
"        if (flagp[IX(i, j - 1, k)] == FLUID) {\n"
"          an[IX(i, j - 1, k)] = 0;\n"
"          tmp1 = j - 1;\n"
"          D = 0.5f * length_z(para, var, &i, &tmp1, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          b[IX(i, j - 1, k)] += rhoCp_1 * qfluxbc[IX(i, j, k)] * azx;\n"
"          // get the temperature of solid surface\n"
"          psi[IX(i, j, k)] = qfluxbc[IX(i, j, k)] / h + psi[IX(i, j - 1, k)];\n"
"        }\n"
"      }\n"
"      // Between South and North\n"
"      else {\n"
"        // Southern neighbor is fluid\n"
"        if (flagp[IX(i, j - 1, k)] == FLUID) {\n"
"          an[IX(i, j - 1, k)] = 0;\n"
"          tmp1 = j - 1;\n"
"          D = 0.5f * length_z(para, var,  &i, &tmp1, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          b[IX(i, j - 1, k)] += rhoCp_1 * qfluxbc[IX(i, j, k)] * azx;\n"
"          // get the temperature of solid surface\n"
"          psi[IX(i, j, k)] = qfluxbc[IX(i, j, k)] / h + psi[IX(i, j - 1, k)];\n"
"        }\n"
"        // Northern neighbor is fluid\n"
"        if (flagp[IX(i, j + 1, k)] == FLUID) {\n"
"          as[IX(i, j + 1, k)] = 0;\n"
"          tmp1 = j + 1;\n"
"          D = 0.5f * length_z(para, var,  &i, &tmp1, &k);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          b[IX(i, j + 1, k)] += rhoCp_1 * qfluxbc[IX(i, j, k)] * azx;\n"
"          // get the temperature of solid surface\n"
"          psi[IX(i, j, k)] = qfluxbc[IX(i, j, k)] / h + psi[IX(i, j + 1, k)];\n"
"        }\n"
"      }\n"
"      // Floor boundary and ceiling neighbor is fluid\n"
"      if (k == 0) {\n"
"        if (flagp[IX(i, j, k + 1)] == FLUID) {\n"
"          ab[IX(i, j, k + 1)] = 0;\n"
"          tmp1 = k + 1;\n"
"          D = 0.5f * length_z(para, var, &i, &j, &tmp1);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          b[IX(i, j, k + 1)] += rhoCp_1 * qfluxbc[IX(i, j, k)] * axy;\n"
"          // Get the temperature on the solid surface\n"
"          psi[IX(i, j, k)] = qfluxbc[IX(i, j, k)] / h + psi[IX(i, j, k + 1)];\n"
"        }\n"
"      }\n"
"      // Ceiling boundary and floor neighbor is fluid\n"
"      else if (k == kmax + 1) {\n"
"        if (flagp[IX(i, j, k - 1)] == FLUID) {\n"
"          af[IX(i, j, k - 1)] = 0;\n"
"          tmp1 = k - 1;\n"
"          D = 0.5f * length_z(para, var, &i, &j, &tmp1);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          b[IX(i, j, k - 1)] += rhoCp_1 * qfluxbc[IX(i, j, k)] * axy;\n"
"          // Get the temperature on the solid surface\n"
"          psi[IX(i, j, k)] = qfluxbc[IX(i, j, k)] / h + psi[IX(i, j, k - 1)];\n"
"        }\n"
"      }\n"
"      // Between Floor and Ceiling\n"
"      else {\n"
"        // Ceiling neighbor is fluid\n"
"        if (flagp[IX(i, j, k + 1)] == FLUID) {\n"
"          ab[IX(i, j, k + 1)] = 0;\n"
"          tmp1 = k + 1;\n"
"          D = 0.5f * length_z(para, var, &i, &j, &tmp1);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          b[IX(i, j, k + 1)] += rhoCp_1 * qfluxbc[IX(i, j, k)] * axy;\n"
"          // Get the temperature on the solid surface\n"
"          psi[IX(i, j, k)] = qfluxbc[IX(i, j, k)] / h + psi[IX(i, j, k + 1)];\n"
"        }\n"
"        // Floor neighbor is fluid\n"
"        if (flagp[IX(i, j, k - 1)] == FLUID) {\n"
"          af[IX(i, j, k - 1)] = 0;\n"
"          tmp1 = k - 1;\n"
"          D = 0.5f * length_z(para, var, &i, &j, &tmp1);\n"
"          h = para->prob.Cp * para->prob.rho * para->prob.alpha / D;\n"
"          h = para->prob.Cp * para->prob.rho *para->prob.coeff_h;\n"
"          b[IX(i, j, k - 1)] += rhoCp_1 * qfluxbc[IX(i, j, k)] * axy;\n"
"          // Get the temperature on the solid surface\n"
"          psi[IX(i, j, k)] = qfluxbc[IX(i, j, k)] / h + psi[IX(i, j, k - 1)];\n"
"        }\n"
"      }\n"
"    } // End of constant heat flux\n"
"  } // End of wall boundary\n"
"\n"
"  /*-------------------------------------------------------------------------\n"
"  | Outlet boundary\n"
"  -------------------------------------------------------------------------*/\n"
"  if (flagp[IX(i, j, k)] == OUTLET) {\n"
"    // West\n"
"    if (i == 0) {\n"
"      aw[IX(i + 1, j, k)] = 0;\n"
"      psi[IX(i, j, k)] = psi[IX(i + 1, j, k)];\n"
"    }\n"
"    // North\n"
"    if (i == imax + 1) {\n"
"      ae[IX(i - 1, j, k)] = 0;\n"
"      psi[IX(i, j, k)] = psi[IX(i - 1, j, k)];\n"
"    }\n"
"    // South\n"
"    if (j == 0) {\n"
"      as[IX(i, j + 1, k)] = 0;\n"
"      psi[IX(i, j, k)] = psi[IX(i, j + 1, k)];\n"
"    }\n"
"    // North\n"
"    if (j == jmax + 1) {\n"
"      an[IX(i, j - 1, k)] = 0;\n"
"      psi[IX(i, j, k)] = psi[IX(i, j - 1, k)];\n"
"    }\n"
"    // Floor\n"
"    if (k == 0) {\n"
"      ab[IX(i, j, k + 1)] = 0;\n"
"      psi[IX(i, j, k)] = psi[IX(i, j, k + 1)];\n"
"    }\n"
"    // Ceiling\n"
"    if (k == kmax + 1) {\n"
"      af[IX(i, j, k - 1)] = 0;\n"
"      psi[IX(i, j, k)] = psi[IX(i, j, k - 1)];\n"
"    }\n"
"  } // End of boundary for outlet\n"
"\n"
"} //end of set_bnd_T()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// set boundary conditions for advection of temperature, solved by implicit scheme\n"
"/// 8/8/2017\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void set_bnd_T_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX) {\n"
"  int it = get_global_id(0);\n"
"  int i, j, k;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"  __global REAL *aw = &var[AW*size], *ae = &var[AE*size], *as = &var[AS*size], *an = &var[AN*size];\n"
"  __global REAL *af = &var[AF*size], *ab = &var[AB*size], *b = &var[B*size];\n"
"  __global REAL *flagp = &var[FLAGP*size];\n"
"  __global REAL *psi;\n"
"\n"
"  // get the index\n"
"  i = BINDEX[0*size+it];\n"
"  j = BINDEX[1*size+it];\n"
"  k = BINDEX[2*size+it];\n"
"\n"
"  // if Advection, psi is assigned the pointer of tmp1\n"
"  psi = &var[TMP1*size];\n"
"\n"
"  // start assigning the boundary conditions\n"
"  // : inlet\n"
"  if (flagp[IX(i, j, k)] == INLET || flagp[IX(i,j,k)] == RACK_OUTLET) psi[IX(i, j, k)] = var[TEMPBC*size + IX(i, j, k)];\n"
"\n"
"  // : wall\n"
"  if (flagp[IX(i, j, k)] == SOLID) {\n"
"    //: temperature as boundary condition type, then give the BC set by user\n"
"    if (BINDEX[3*size + it] == 0) {\n"
"      psi[IX(i, j, k)] = var[TEMPBC*size + IX(i, j, k)];\n"
"    }\n"
"    //: heat flux as boundary condition type, then give the temperature at wall from last step\n"
"    else {\n"
"      psi[IX(i, j, k)] = var[TEMP*size + IX(i, j, k)];\n"
"    }\n"
"  } // end of solid wall\n"
"\n"
"  // : outlet\n"
"  if (flagp[IX(i, j, k)] == OUTLET || flagp[IX(i, j, k)] == TILE) {\n"
"    // :west\n"
"    if (i == 0) {\n"
"      psi[IX(i, j, k)] = psi[IX(i + 1, j, k)];\n"
"    } // end of i==0\n"
"    // :east\n"
"    if (i == imax + 1) {\n"
"      psi[IX(i, j, k)] = psi[IX(i - 1, j, k)];\n"
"    } // end of i == imax+1\n"
"    // :south\n"
"    if (j == 0) {\n"
"      psi[IX(i, j, k)] = psi[IX(i, j + 1, k)];\n"
"    } // end of j==0\n"
"    // :north\n"
"    if (j == jmax + 1) {\n"
"      psi[IX(i, j, k)] = psi[IX(i, j - 1, k)];\n"
"    } // end of j == jmax+1\n"
"    // :floor\n"
"    if (k == 0) {\n"
"      psi[IX(i, j, k)] = psi[IX(i, j, k + 1)];\n"
"    } // end of k ==0\n"
"    //: ceiling\n"
"    if (k == kmax + 1) {\n"
"      psi[IX(i, j, k)] = psi[IX(i, j, k - 1)];\n"
"    } // end of k ==kmax+1\n"
"  } // end of outlet\n"
"\n"
"} //end of set_bnd_T_im\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// set boundary conditions for pressure\n"
"/// 6/19/2015\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"\n"
"__kernel void set_bnd_pressure(__global PARA_DATA_SIMP *para, __global REAL *var,__global int *BINDEX) {\n"
"    int it = get_global_id(0);\n"
"  int i, j, k;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"  __global REAL *aw = &var[AW*size], *ae = &var[AE*size], *as = &var[AS*size], *an = &var[AN*size];\n"
"  __global REAL *af = &var[AF*size], *ab = &var[AB*size];\n"
"  __global REAL *flagp = &var[FLAGP*size];\n"
"  __global REAL *p = &var[IP*size];\n"
"\n"
"    // get the index\n"
"  i = BINDEX[0*size+it];\n"
"    j = BINDEX[1*size+it];\n"
"    k = BINDEX[2*size+it];\n"
"\n"
"  /*-------------------------------------------------------------------------\n"
"    | For X direction\n"
"    -------------------------------------------------------------------------*/\n"
"    if(i>0) {\n"
"      if(flagp[IX(i-1,j,k)]<0) {\n"
"        p[IX(i,j,k)] = p[IX(i-1,j,k)];\n"
"        ae[IX(i-1,j,k)] = 0;\n"
"      }\n"
"    }\n"
"    if(i<imax+1) {\n"
"      if(flagp[IX(i+1,j,k )]<0) {\n"
"        p[IX(i,j,k)] = p[IX(i+1,j,k)];\n"
"        aw[IX(i+1,j,k)] = 0;\n"
"      }\n"
"    }\n"
"    /*-------------------------------------------------------------------------\n"
"    | For Y direction\n"
"    -------------------------------------------------------------------------*/\n"
"    if(j>0) {\n"
"      if(flagp[IX(i,j-1,k)]<0) {\n"
"        p[IX(i,j,k)] = p[IX(i,j-1,k )];\n"
"        an[IX(i,j-1,k)] = 0;\n"
"      }\n"
"    }\n"
"    if(j<jmax+1) {\n"
"      if(flagp[IX(i,j+1,k)]<0) {\n"
"        p[IX(i,j,k )] = p[IX(i,j+1,k )];\n"
"        as[IX(i,j+1,k)] = 0;\n"
"      }\n"
"    }\n"
"    /*-------------------------------------------------------------------------\n"
"    | For Z direction\n"
"    -------------------------------------------------------------------------*/\n"
"    if(k>0) {\n"
"      if(flagp[IX(i,j,k-1)]<0) {\n"
"        p[IX(i,j,k)] = p[IX(i,j,k-1)];\n"
"        af[IX(i,j,k-1)] = 0;\n"
"      }\n"
"    }\n"
"    if(k<kmax+1) {\n"
"      if(flagp[IX(i,j,k+1 )]<0) {\n"
"        p[IX(i,j,k)] = p[IX(i,j,k+1)];\n"
"        ab[IX(i,j,k+1)] = 0;\n"
"      }\n"
"    }\n"
"} //end of set_bnd_pressure()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// set boundary conditions for VX\n"
"/// 6/12/2015\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void set_bnd_VX(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *WF, __global int *BINDEX) {\n"
"  int it = get_global_id(0);\n"
"  int i, j, k;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"  __global REAL *aw = &var[AW*size], *ae = &var[AE*size], *as = &var[AS*size], *an = &var[AN*size];\n"
"  __global REAL *af = &var[AF*size], *ab = &var[AB*size], *b = &var[B*size];\n"
"  __global REAL *flagp = &var[FLAGP*size];\n"
"  __global REAL *psi;\n"
"\n"
"  // get the index\n"
"  i = BINDEX[0*size+it];\n"
"  j = BINDEX[1*size+it];\n"
"  k = BINDEX[2*size+it];\n"
"\n"
"  // if Advection\n"
"  if (WF[0] == 0) {\n"
"    psi = &var[TMP1*size];\n"
"  }\n"
"  // else if diffusion\n"
"  else if (WF[0] == 1) {\n"
"    psi = &var[VX*size];\n"
"  }\n"
"\n"
"  //printf(\"the FUNC is %d \", WF[0]);\n"
"  // Inlet\n"
"  if (flagp[IX(i, j, k)] == INLET) {\n"
"    psi[IX(i, j, k)] = var[VXBC*size+IX(i, j, k)];\n"
"    if (i != 0) psi[IX(i - 1, j, k)] = var[VXBC*size+IX(i, j, k)];\n"
"  } //end of if (flagp[IX(i, j, k)] == INLET)\n"
"\n"
"  // Rack outlet\n"
"  if(flagp[IX(i,j,k)]==RACK_OUTLET) {\n"
"    psi[IX(i, j, k)] = var[VXBC*size+IX(i, j, k)];\n"
"    if (i != 0) psi[IX(i - 1, j, k)] = var[VXBC*size+IX(i, j, k)];\n"
"  }	\n"
"\n"
"  // Solid wall\n"
"  if (flagp[IX(i, j, k)] == SOLID) {\n"
"      if (k==kmax+1) {\n"
"      psi[IX(i, j, k)] = 0.0;\n"
"    }\n"
"    else {\n"
"      psi[IX(i, j, k)] = 0;\n"
"      if (i != 0) psi[IX(i - 1, j, k)] = 0;\n"
"    }\n"
"  } //end of if (flagp[IX(i, j, k)] == SOLID)\n"
"\n"
"  // Tile\n"
"  if (flagp[IX(i, j, k)] == TILE) {\n"
"    // if solving tile using presure correction method\n"
"    if (flagp[IX(i, j, k)] == TILE && para->solv.tile_flow_correct == PRESSURE_BASE) {\n"
"      // West\n"
"      if (i == 0) {\n"
"        psi[IX(i, j, k)] = var[TILE_FLOW_BC*size+IX(i, j, k)];\n"
"      }\n"
"      // East\n"
"      if (i == imax + 1) {\n"
"        psi[IX(i - 1, j, k)] = var[TILE_FLOW_BC*size+IX(i, j, k)];\n"
"      }\n"
"    }\n"
"  } //end of if (flagp[IX(i, j, k)] == TILE)\n"
"\n"
"  // Outlets\n"
"  if (flagp[IX(i, j, k)] == OUTLET){\n"
"    if (para->bc_simp.outlet_bc == PRESCRIBED_VALUE){\n"
"      //east\n"
"      if (i == imax + 1) {\n"
"        psi[IX(i-1,j,k)] = var[VXBC*size+IX(i,j,k)];\n"
"      }\n"
"      else {\n"
"        psi[IX(i,j,k)] = var[VXBC*size+IX(i,j,k)];\n"
"      }\n"
"    }\n"
"    else {\n"
"      // West\n"
"      if (i == 0) {\n"
"        psi[IX(i, j, k)] = psi[IX(i + 1, j, k)];\n"
"        aw[IX(i + 1, j, k)] = 0;\n"
"      }\n"
"      // East\n"
"      if (i == imax + 1) {\n"
"        psi[IX(i - 1, j, k)] = psi[IX(i - 2, j, k)];\n"
"        ae[IX(i - 2, j, k)] = 0;\n"
"      }\n"
"      // South\n"
"      if (j == 0) as[IX(i, j + 1, k)] = 0;\n"
"      // North\n"
"      if (j == jmax + 1) an[IX(i, j - 1, k)] = 0;\n"
"      // Floor\n"
"      if (k == 0) ab[IX(i, j, k + 1)] = 0;\n"
"      // Ceiling\n"
"      if (k == kmax + 1) af[IX(i, j, k - 1)] = 0;\n"
"    } //end of if (para->bc_simp.outlet_bc == PRESCRIBED_VALUE)\n"
"  } //end of if (flagp[IX(i, j, k)] == OUTLET)\n"
"\n"
"  // Rack inlet\n"
"  if (flagp[IX(i,j,k)] == RACK_INLET){\n"
"    // if west side is fluid\n"
"    if (flagp[IX(i-1,j,k)] == FLUID) {\n"
"      psi[IX(i-1,j,k)] = var[VXBC*size+IX(i,j,k)];\n"
"    }\n"
"    // if east side is fluid\n"
"    if (flagp[IX(i+1,j,k)] == FLUID) {\n"
"      psi[IX(i,j,k)] = var[VXBC*size+IX(i,j,k)];\n"
"    }\n"
"  } //if(flagp[IX(i,j,k)] == RACK_INLET)\n"
"}//end of set_bnd_VX()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// set boundary conditions for VX for advection solved by implicit scheme\n"
"/// 8/8/2017\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void set_bnd_VX_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX) {\n"
"  int it = get_global_id(0);\n"
"  int i, j, k;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"  __global REAL *aw = &var[AW*size], *ae = &var[AE*size], *as = &var[AS*size], *an = &var[AN*size];\n"
"  __global REAL *af = &var[AF*size], *ab = &var[AB*size], *b = &var[B*size];\n"
"  __global REAL *flagp = &var[FLAGP*size];\n"
"  __global REAL *psi;\n"
"\n"
"  // get the index\n"
"  i = BINDEX[0*size+it];\n"
"  j = BINDEX[1*size+it];\n"
"  k = BINDEX[2*size+it];\n"
"\n"
"  // if advection, psi is tmp1\n"
"  psi = &var[TMP1*size];\n"
"\n"
"  // start assigning the boundary condition\n"
"  // :Inlet\n"
"  if (flagp[IX(i, j, k)] == INLET) {\n"
"    psi[IX(i, j, k)] = var[VXBC*size+IX(i, j, k)];\n"
"    if (i != 0) psi[IX(i - 1, j, k)] = var[VXBC*size+IX(i, j, k)];\n"
"  } //end of inlet\n"
"\n"
"  // :Rack outlet\n"
"  if (flagp[IX(i, j, k)] == RACK_OUTLET) {\n"
"	psi[IX(i, j, k)] = var[VXBC*size+IX(i, j, k)];\n"
"    if (i != 0) psi[IX(i - 1, j, k)] = var[VXBC*size+IX(i, j, k)];\n"
"  } //end of rack outlet\n"
"\n"
"  // :Solid\n"
"  if (flagp[IX(i, j, k)] == SOLID) {\n"
"    psi[IX(i, j, k)] = 0;\n"
"    if (i != 0) psi[IX(i - 1, j, k)] = 0;\n"
"  } // end of solid\n"
"\n"
"  // Tile\n"
"  if (flagp[IX(i, j, k)] == TILE) {\n"
"    if (para->solv.tile_flow_correct == PRESSURE_BASE){\n"
"      if (i == 0 ) {\n"
"        psi[IX(i, j, k)] = var[TILE_FLOW_BC*size+IX(i, j, k)];\n"
"      }\n"
"      if (i == imax+1) {\n"
"        psi[IX(i - 1, j, k)] = var[TILE_FLOW_BC*size+IX(i, j, k)];\n"
"      }\n"
"    }\n"
"  } //end of if (flagp[IX(i, j, k)] == TILE)\n"
"\n"
"  // :Outlet\n"
"  if (flagp[IX(i, j, k)] == OUTLET) {\n"
"    if (para->bc_simp.outlet_bc == PRESCRIBED_VALUE){\n"
"      //east\n"
"      if (i == imax + 1) {\n"
"        psi[IX(i-1,j,k)] = var[VXBC*size+IX(i,j,k)];\n"
"      }\n"
"      else {\n"
"        psi[IX(i,j,k)] = var[VXBC*size+IX(i,j,k)];\n"
"      }\n"
"    }\n"
"    else {\n"
"      // :west\n"
"      if (i == 0) {\n"
"        psi[IX(i, j, k)] = psi[IX(i + 1, j, k)];\n"
"      }\n"
"      // :east\n"
"      if (i == imax + 1) {\n"
;


const char source_str4[] =
"        psi[IX(i - 1, j, k)] = psi[IX(i - 2, j, k)];\n"
"      }\n"
"    } //end if (para->bc_simp.outlet_bc == PRESCRIBED_VALUE)\n"
"  } //end of if (flagp[IX(i, j, k)] == OUTLET)\n"
"\n"
"  // Rack inlet\n"
"  if (flagp[IX(i,j,k)] == RACK_INLET){\n"
"    // if west side is fluid\n"
"    if (flagp[IX(i-1,j,k)] == FLUID) {\n"
"      psi[IX(i-1,j,k)] = var[VXBC*size+IX(i,j,k)];\n"
"    }\n"
"    // if east side is fluid\n"
"    if (flagp[IX(i+1,j,k)] == FLUID) {\n"
"      psi[IX(i,j,k)] = var[VXBC*size+IX(i,j,k)];\n"
"    }\n"
"  } //if(flagp[IX(i,j,k)] == RACK_INLET)\n"
"} // end of set_bnd_VX_im\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// set boundary conditions for VY\n"
"/// 6/12/2015\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void set_bnd_VY(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *WF, __global int *BINDEX) {\n"
"  int it = get_global_id(0);\n"
"  int i, j, k;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"  __global REAL *aw = &var[AW*size], *ae = &var[AE*size], *as = &var[AS*size], *an = &var[AN*size];\n"
"  __global REAL *af = &var[AF*size], *ab = &var[AB*size], *b = &var[B*size];\n"
"  __global REAL *flagp = &var[FLAGP*size];\n"
"  __global REAL *psi;\n"
"  // get the index\n"
"  i = BINDEX[0*size+it];\n"
"  j = BINDEX[1*size+it];\n"
"  k = BINDEX[2*size+it];\n"
"\n"
"  // if Advection\n"
"  if (WF[0] == 0) {\n"
"    psi = &var[TMP2*size];\n"
"  }\n"
"  // else if diffusion\n"
"  else if (WF[0] == 1) {\n"
"    psi = &var[VY*size];\n"
"  }\n"
"\n"
"  // Inlet\n"
"  if (flagp[IX(i, j, k)] == INLET) {\n"
"    psi[IX(i, j, k)] = var[VYBC*size+IX(i, j, k)];\n"
"    if (j != 0) psi[IX(i, j - 1, k)] = var[VYBC*size+IX(i, j, k)];\n"
"  }\n"
"\n"
"  // rack outlet\n"
"  if (flagp[IX(i, j, k)] == RACK_OUTLET) {\n"
"    psi[IX(i, j, k)] = var[VYBC*size+IX(i, j, k)];\n"
"    if (j != 0) psi[IX(i, j - 1, k)] = var[VYBC*size+IX(i, j, k)];\n"
"  }\n"
"\n"
"  // Solid wall\n"
"  if (flagp[IX(i, j, k)] == SOLID) {\n"
"    psi[IX(i, j, k)] = 0;\n"
"    if (j != 0) psi[IX(i, j - 1, k)] = 0;\n"
"  }\n"
"\n"
"  // Tile\n"
"  if (flagp[IX(i, j, k)] == TILE) {\n"
"    // if solving tile using presure correction method\n"
"    if (para->solv.tile_flow_correct == PRESSURE_BASE) {\n"
"      // South\n"
"      if (j == 0) {\n"
"        psi[IX(i, j, k)] = var[TILE_FLOW_BC*size+IX(i, j, k)];\n"
"      }\n"
"      // North\n"
"      if (j == jmax + 1) {\n"
"        psi[IX(i, j - 1, k)] = var[TILE_FLOW_BC*size+IX(i, j, k)];\n"
"      }\n"
"    }\n"
"  } //end of if (flagp[IX(i, j, k)] == TILE)\n"
"\n"
"  // Outlet\n"
"  if (flagp[IX(i, j, k)] == OUTLET) {\n"
"    if (para->bc_simp.outlet_bc == PRESCRIBED_VALUE){\n"
"      //north\n"
"      if (j == jmax + 1) {\n"
"        psi[IX(i,j-1,k)] = var[VYBC*size+IX(i,j,k)];\n"
"      }\n"
"      else {\n"
"        psi[IX(i,j,k)] = var[VYBC*size+IX(i,j,k)];\n"
"      }\n"
"    }\n"
"    else {\n"
"      // West\n"
"      if (i == 0) aw[IX(i + 1, j, k)] = 0;\n"
"      // East\n"
"      if (i == imax + 1) ae[IX(i - 1, j, k)] = 0;\n"
"      // South\n"
"      if (j == 0) {\n"
"        as[IX(i, j + 1, k)] = 0;\n"
"        psi[IX(i, j, k)] = psi[IX(i, j + 1, k)];\n"
"      }\n"
"      // North\n"
"      if (j == jmax + 1) {\n"
"        an[IX(i, j - 2, k)] = 0;\n"
"        psi[IX(i, j - 1, k)] = psi[IX(i, j - 2, k)];\n"
"      }\n"
"      // Floor\n"
"      if (k == 0) ab[IX(i, j, k + 1)] = 0;\n"
"      // Ceiling\n"
"      if (k == kmax + 1) af[IX(i, j, k - 1)] = 0;\n"
"    } //end of if (para->bc_simp.outlet_bc == PRESCRIBED_VALUE)\n"
"  } //end of if (flagp[IX(i, j, k)] == OUTLET)\n"
"\n"
"  // Rack inlet\n"
"  if(flagp[IX(i,j,k)] == RACK_INLET){\n"
"    // if south side is fluid\n"
"    if (flagp[IX(i,j-1,k)] == FLUID) {\n"
"      psi[IX(i,j-1,k)] = var[VYBC*size+IX(i,j,k)];\n"
"    }\n"
"    // if north side is fluid\n"
"    if (flagp[IX(i,j+1,k)] == FLUID) {\n"
"      psi[IX(i,j,k)] = var[VYBC*size+IX(i,j,k)];\n"
"    }\n"
"  }// end of setting rack inlet\n"
"}//end of set_bnd_VY()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// set boundary conditions for VY for advection solved by implicit scheme\n"
"/// 8/8/2017\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void set_bnd_VY_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX) {\n"
"  int it = get_global_id(0);\n"
"  int i, j, k;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"  __global REAL *aw = &var[AW*size], *ae = &var[AE*size], *as = &var[AS*size], *an = &var[AN*size];\n"
"  __global REAL *af = &var[AF*size], *ab = &var[AB*size], *b = &var[B*size];\n"
"  __global REAL *flagp = &var[FLAGP*size];\n"
"  __global REAL *psi;\n"
"\n"
"  // get the index\n"
"  i = BINDEX[0*size+it];\n"
"  j = BINDEX[1*size+it];\n"
"  k = BINDEX[2*size+it];\n"
"\n"
"  // if Advection, psi is tmp2\n"
"  psi = &var[TMP2*size];\n"
"\n"
"  // start assigning boundary conditions\n"
"  // :Inlet\n"
"  if (flagp[IX(i, j, k)] == INLET) {\n"
"    psi[IX(i, j, k)] = var[VYBC*size+IX(i, j, k)];\n"
"    if (j != 0) psi[IX(i, j - 1, k)] = var[VYBC*size+IX(i, j, k)];\n"
"  }\n"
"\n"
"  // rack outlet\n"
"  if (flagp[IX(i, j, k)] == RACK_OUTLET) {\n"
"    psi[IX(i, j, k)] = var[VYBC*size+IX(i, j, k)];\n"
"    if (j != 0) psi[IX(i, j - 1, k)] = var[VYBC*size+IX(i, j, k)];\n"
"  }\n"
"\n"
"  // :Solid\n"
"  if (flagp[IX(i, j, k)] == SOLID) {\n"
"    psi[IX(i, j, k)] = 0;\n"
"    if (j != 0) psi[IX(i, j - 1, k)] = 0;\n"
"  }\n"
"\n"
"  // Tile\n"
"  if (flagp[IX(i, j, k)] == TILE) {\n"
"    // if solving tile using presure correction method\n"
"    if (para->solv.tile_flow_correct == PRESSURE_BASE) {\n"
"      // South\n"
"      if (j == 0) {\n"
"        psi[IX(i, j, k)] = var[TILE_FLOW_BC*size+IX(i, j, k)];\n"
"      }\n"
"      // North\n"
"      if (j == jmax + 1) {\n"
"        psi[IX(i, j - 1, k)] = var[TILE_FLOW_BC*size+IX(i, j, k)];\n"
"      }\n"
"    }\n"
"  } //end of if (flagp[IX(i, j, k)] == TILE)\n"
"\n"
"  // :Outlet\n"
"  if (flagp[IX(i, j, k)] == OUTLET) {\n"
"    if (para->bc_simp.outlet_bc == PRESCRIBED_VALUE){\n"
"      //north\n"
"      if (j == jmax + 1) {\n"
"        psi[IX(i,j-1,k)] = var[VYBC*size+IX(i,j,k)];\n"
"      }\n"
"      else {\n"
"        psi[IX(i,j,k)] = var[VYBC*size+IX(i,j,k)];\n"
"      }\n"
"    }\n"
"    else {\n"
"      // :south\n"
"      if (j == 0) {\n"
"        psi[IX(i, j, k)] = psi[IX(i, j + 1, k)];\n"
"      }\n"
"      // :north\n"
"      if (j == jmax + 1) {\n"
"        psi[IX(i, j - 1, k)] = psi[IX(i, j - 2, k)];\n"
"      }\n"
"    }\n"
"  } //end of if (flagp[IX(i, j, k)] == OUTLET)\n"
"\n"
"  // Rack inlet\n"
"  if(flagp[IX(i,j,k)] == RACK_INLET){\n"
"    // if south side is fluid\n"
"    if (flagp[IX(i,j-1,k)] == FLUID) {\n"
"      psi[IX(i,j-1,k)] = var[VYBC*size+IX(i,j,k)];\n"
"    }\n"
"    // if north side is fluid\n"
"    if (flagp[IX(i,j+1,k)] == FLUID) {\n"
"      psi[IX(i,j,k)] = var[VYBC*size+IX(i,j,k)];\n"
"    }\n"
"  }// end of setting rack inlet\n"
"} //end of void set_bnd_VY_im\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// set boundary conditions for VZ\n"
"/// 6/12/2015\n"
"// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void set_bnd_VZ(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *WF, __global int *BINDEX) {\n"
"  int it = get_global_id(0);\n"
"  int i, j, k;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"  __global REAL *aw = &var[AW*size], *ae = &var[AE*size], *as = &var[AS*size], *an = &var[AN*size];\n"
"  __global REAL *af = &var[AF*size], *ab = &var[AB*size], *b = &var[B*size];\n"
"  __global REAL *flagp = &var[FLAGP*size];\n"
"  __global REAL *psi;\n"
"  // get the index\n"
"  i = BINDEX[0*size+it];\n"
"  j = BINDEX[1*size+it];\n"
"  k = BINDEX[2*size+it];\n"
"  // if Advection\n"
"  if (WF[0] == 0) {\n"
"    psi = &var[TMP3*size];\n"
"  }\n"
"  // else if diffusion\n"
"  else if (WF[0] == 1) {\n"
"    psi = &var[VZ*size];\n"
"  }\n"
"  // Inlet\n"
"  if (flagp[IX(i, j, k)] == INLET) {\n"
"    psi[IX(i, j, k)] = var[VZBC*size+IX(i, j, k)];\n"
"    if (k != 0) psi[IX(i, j, k - 1)] = var[VZBC*size+IX(i, j, k)];\n"
"  }\n"
"\n"
"  // Rack outlet\n"
"  if (flagp[IX(i, j, k)] == RACK_OUTLET) {\n"
"    psi[IX(i, j, k)] = var[VZBC*size+IX(i, j, k)];\n"
"    if (k != 0) psi[IX(i, j, k - 1)] = var[VZBC*size+IX(i, j, k)];\n"
"  }\n"
"\n"
"  // Solid\n"
"  if (flagp[IX(i, j, k)] == SOLID) {\n"
"    psi[IX(i, j, k)] = 0;\n"
"    if (k != 0) psi[IX(i, j, k - 1)] = 0;\n"
"  }\n"
"\n"
"  // Tile\n"
"  if (flagp[IX(i, j, k)] == TILE) {\n"
"    // if solving tile using presure correction method\n"
"    if(para->solv.tile_flow_correct == PRESSURE_BASE) {\n"
"      // Floor\n"
"      if (k == 0) {\n"
"        psi[IX(i, j, k)] = var[TILE_FLOW_BC*size+IX(i, j, k)];\n"
"      }\n"
"      // Ceiling\n"
"      if (k == kmax + 1) {\n"
"        psi[IX(i, j, k - 1)] = var[TILE_FLOW_BC*size+IX(i, j, k)];\n"
"      }\n"
"    }\n"
"  } //end of if (flagp[IX(i, j, k)] == TILE)\n"
"\n"
"  // Outlet\n"
"  if (flagp[IX(i, j, k)] == OUTLET) {\n"
"    if (para->bc_simp.outlet_bc == PRESCRIBED_VALUE){\n"
"      //north\n"
"      if (k == kmax + 1) {\n"
"        psi[IX(i,j,k-1)] = var[VZBC*size+IX(i,j,k)];\n"
"      }\n"
"      else {\n"
"        psi[IX(i,j,k)] = var[VZBC*size+IX(i,j,k)];\n"
"      }\n"
"    }\n"
"    else {\n"
"      // West\n"
"      if (i == 0) aw[IX(i + 1, j, k)] = 0;\n"
"      // East\n"
"      if (i == imax + 1) ae[IX(i - 1, j, k)] = 0;\n"
"      //South\n"
"      if (j == 0) as[IX(i, j + 1, k)] = 0;\n"
"      // North\n"
"      if (j == jmax + 1) an[IX(i, j - 1, k)] = 0;\n"
"      // Floor\n"
"      if (k == 0) {\n"
"        ab[IX(i, j, k + 1)] = 0;\n"
"        psi[IX(i, j, k)] = psi[IX(i, j, k + 1)];\n"
"      }\n"
"      // Ceiling\n"
"      if (k == kmax + 1) {\n"
"        af[IX(i, j, k - 2)] = 0;\n"
"        psi[IX(i, j, k - 1)] = psi[IX(i, j, k - 2)];\n"
"      }\n"
"    } //end of if (para->bc_simp.outlet_bc == PRESCRIBED_VALUE)\n"
"  } //end of if (flagp[IX(i, j, k)] == OUTLET)\n"
"\n"
"  // Rack inlet\n"
"  if(flagp[IX(i,j,k)]==RACK_INLET){\n"
"    // if back side is fluid\n"
"    if (flagp[IX(i,j,k-1)] == FLUID) {\n"
"      psi[IX(i,j,k-1)] = var[VZBC*size+IX(i,j,k)];\n"
"    }\n"
"    // if front side is fluid\n"
"    if (flagp[IX(i,j,k+1)] == FLUID) {\n"
"      psi[IX(i,j,k)] = var[VZBC*size+IX(i,j,k)];\n"
"    }\n"
"  }// end of setting rack inlet	\n"
"}//end of set_bnd_VZ()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// set boundary conditions for VZ for advection solved by implicit scheme\n"
"/// 8/8/2017\n"
"/// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void set_bnd_VZ_im(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX) {\n"
"  int it = get_global_id(0);\n"
"  int i, j, k;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int size = (imax + 2)*(jmax + 2)*(kmax + 2);\n"
"  int IMAX = imax + 2, IJMAX = (imax + 2)*(jmax + 2);\n"
"  __global REAL *aw = &var[AW*size], *ae = &var[AE*size], *as = &var[AS*size], *an = &var[AN*size];\n"
"  __global REAL *af = &var[AF*size], *ab = &var[AB*size], *b = &var[B*size];\n"
"  __global REAL *flagp = &var[FLAGP*size];\n"
"  __global REAL *psi;\n"
"\n"
"  // get the index\n"
"  i = BINDEX[0*size+it];\n"
"  j = BINDEX[1*size+it];\n"
"  k = BINDEX[2*size+it];\n"
"\n"
"  // if Advection\n"
"  psi = &var[TMP3*size];\n"
"\n"
"  // :Inlet\n"
"  if (flagp[IX(i, j, k)] == INLET) {\n"
"    psi[IX(i, j, k)] = var[VZBC*size+IX(i, j, k)];\n"
"    if (k != 0) psi[IX(i, j, k - 1)] = var[VZBC*size+IX(i, j, k)];\n"
"  } // end of inlet\n"
"\n"
"  // Rack outlet\n"
"  if (flagp[IX(i, j, k)] == RACK_OUTLET) {\n"
"    psi[IX(i, j, k)] = var[VZBC*size+IX(i, j, k)];\n"
"    if (k != 0) psi[IX(i, j, k - 1)] = var[VZBC*size+IX(i, j, k)];\n"
"  }\n"
"\n"
"  // :Solid\n"
"  if (flagp[IX(i, j, k)] == SOLID) {\n"
"    psi[IX(i, j, k)] = 0;\n"
"    if (k != 0) psi[IX(i, j, k - 1)] = 0;\n"
"  } //end of solid\n"
"\n"
"  // Tile\n"
"  if (flagp[IX(i, j, k)] == TILE) {\n"
"    // if solving tile using presure correction method\n"
"    if(para->solv.tile_flow_correct == PRESSURE_BASE) {\n"
"      // Floor\n"
"      if (k == 0) {\n"
"        psi[IX(i, j, k)] = var[TILE_FLOW_BC*size+IX(i, j, k)];\n"
"      }\n"
"      // Ceiling\n"
"      if (k == kmax + 1) {\n"
"        psi[IX(i, j, k - 1)] = var[TILE_FLOW_BC*size+IX(i, j, k)];\n"
"      }\n"
"    }\n"
"  } //end of if (flagp[IX(i, j, k)] == TILE)\n"
"\n"
"  // :Outlet\n"
"  if (flagp[IX(i, j, k)] == OUTLET) {\n"
"    if (para->bc_simp.outlet_bc == PRESCRIBED_VALUE){\n"
"      //north\n"
"      if (k == kmax + 1) {\n"
"        psi[IX(i,j,k-1)] = var[VZBC*size+IX(i,j,k)];\n"
"      }\n"
"      else {\n"
"        psi[IX(i,j,k)] = var[VZBC*size+IX(i,j,k)];\n"
"      }\n"
"    }\n"
"    else {\n"
"      // :Floor\n"
"      if (k == 0) {\n"
"        psi[IX(i, j, k)] = psi[IX(i, j, k + 1)];\n"
"      }\n"
"      // :Ceiling\n"
"      if (k == kmax + 1) {\n"
"        psi[IX(i, j, k - 1)] = psi[IX(i, j, k - 2)];\n"
"      }\n"
"    }\n"
"  } //end of if (flagp[IX(i, j, k)] == OUTLET)\n"
"\n"
"  // Rack inlet\n"
"  if(flagp[IX(i,j,k)]==RACK_INLET){\n"
"    // if back side is fluid\n"
"    if (flagp[IX(i,j,k-1)] == FLUID) {\n"
"      psi[IX(i,j,k-1)] = var[VZBC*size+IX(i,j,k)];\n"
"    }\n"
"    // if front side is fluid\n"
"    if (flagp[IX(i,j,k+1)] == FLUID) {\n"
"      psi[IX(i,j,k)] = var[VZBC*size+IX(i,j,k)];\n"
"    }\n"
"  }// end of setting rack inlet	\n"
"} // end of set_bnd_VZ_im\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kernels to set the AP coefficients\n"
"/// 6/12/2015\n"
"// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void ap_coeff(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *var_type) {\n"
"\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  __global float *aw = &var[AW*size];\n"
"  __global float *ae = &var[AE*size];\n"
"  __global float *as = &var[AS*size];\n"
"  __global float *an = &var[AN*size];\n"
"  __global float *af = &var[AF*size];\n"
"  __global float *ab = &var[AB*size];\n"
"  __global float *ap = &var[AP*size];\n"
"  __global float *ap0 = &var[AP0*size];\n"
"    // U\n"
"  if (var_type[0] == VX) {\n"
"    // FOR_U_CELL\n"
"    if (i>0 && i<imax && j>0 && j<jmax+1 && k>0 && k<kmax+1) {\n"
"          ap[IX(i,j,k)] = ap0[IX(i,j,k)] + ae[IX(i,j,k)] + aw[IX(i,j,k)]\n"
"                        + an[IX(i,j,k)]  + as[IX(i,j,k)] + af[IX(i,j,k)]\n"
"                        + ab[IX(i,j,k)];\n"
"    } //end of FOR_U_CELL\n"
"\n"
"  } //end of U\n"
"  // V\n"
"  else if (var_type[0] == VY) {\n"
"    // FOR_V_CELL\n"
"    if (i>0 && i<imax+1 && j>0 && j<jmax && k>0 && k<kmax+1) {\n"
"          ap[IX(i,j,k)] = ap0[IX(i,j,k)] + ae[IX(i,j,k)] + aw[IX(i,j,k)]\n"
"                        + an[IX(i,j,k)]  + as[IX(i,j,k)] + af[IX(i,j,k)]\n"
"                        + ab[IX(i,j,k)];\n"
"    } //end of FOR_V_CELL\n"
"  } //end of V\n"
"  // W\n"
"  if (var_type[0] == VZ) {\n"
"    // FOR_W_CELL\n"
"    if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax) {\n"
"          ap[IX(i,j,k)] = ap0[IX(i,j,k)] + ae[IX(i,j,k)] + aw[IX(i,j,k)]\n"
"                        + an[IX(i,j,k)]  + as[IX(i,j,k)] + af[IX(i,j,k)]\n"
"                        + ab[IX(i,j,k)];\n"
"    } //end of FOR_W_CELL\n"
"  } //end of W\n"
"  // T\n"
"  if (var_type[0] == TEMP){\n"
"      // FOR_ALL_CELL\n"
"    if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax+1) {\n"
"          ap[IX(i,j,k)] = ap0[IX(i,j,k)] + ae[IX(i,j,k)] + aw[IX(i,j,k)]\n"
"                        + an[IX(i,j,k)]  + as[IX(i,j,k)] + af[IX(i,j,k)]\n"
"                        + ab[IX(i,j,k)];\n"
"    } //end of FOR_W_CELL\n"
"  } //end of T\n"
"  // Pressure\n"
"  if (var_type[0] == IP){\n"
"    // FOR_ALL_CELL\n"
"    if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax+1) {\n"
"       ap[IX(i,j,k)] = ae[IX(i,j,k)] + aw[IX(i,j,k)] + as[IX(i,j,k)] + an[IX(i,j,k)]\n"
"                  + af[IX(i,j,k)] + ab[IX(i,j,k)];\n"
"    }\n"
"  } //end of Pressure\n"
"} //end of __kernel void ap_coeff\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// kernels to set the AP coefficients\n"
"/// 6/12/2015\n"
"// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void ap_im_coeff(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *var_type) {\n"
"\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  __global float *aw = &var[AW*size];\n"
"  __global float *ae = &var[AE*size];\n"
"  __global float *as = &var[AS*size];\n"
"  __global float *an = &var[AN*size];\n"
"  __global float *af = &var[AF*size];\n"
"  __global float *ab = &var[AB*size];\n"
"  __global float *ap = &var[AP*size];\n"
"  __global float *ap0 = &var[AP0*size];\n"
"\n"
"  __global float *x = &var[X*size];\n"
"  __global float *y = &var[Y*size];\n"
"  __global float *z = &var[Z*size];\n"
"  __global float *gx = &var[GX*size];\n"
"  __global float *gy = &var[GY*size];\n"
"  __global float *gz = &var[GZ*size];\n"
"  __global float *u = &var[VX*size];\n"
"  __global float *v = &var[VY*size];\n"
"  __global float *w = &var[VZ*size];\n"
"\n"
"  REAL dxe, dxw, dyn, dys, dzf, dzb, Dx, Dy, Dz;\n"
"  REAL uw, ue, vs, vn, wb, wf;\n"
"  REAL Fw, Fe, Fs, Fn, Fb, Ff;\n"
"\n"
"    // U\n"
"  if (var_type[0] == VX) {\n"
"    // FOR_U_CELL\n"
"    if (i>0 && i<imax && j>0 && j<jmax+1 && k>0 && k<kmax+1) {\n"
"        // define the dimensions\n"
"        dxe = gx[IX(i + 1, j, k)] - gx[IX(i, j, k)];\n"
"        dxw = gx[IX(i, j, k)] - gx[IX(i - 1, j, k)];\n"
"        Dx = x[IX(i + 1, j, k)] - x[IX(i, j, k)];\n"
"        Dy = gy[IX(i, j, k)] - gy[IX(i, j - 1, k)];\n"
"        Dz = gz[IX(i, j, k)] - gz[IX(i, j, k - 1)];\n"
"\n"
"        // define the velocity at the surface\n"
"        uw = 0.5*(u[IX(i - 1, j, k)] + u[IX(i, j, k)]);\n"
"        ue = 0.5*(u[IX(i, j, k)] + u[IX(i + 1, j, k)]);\n"
"        vs = 0.5*(v[IX(i, j-1, k)] + v[IX(i + 1, j-1, k)]);\n"
"        vn = 0.5*(v[IX(i, j, k)] + v[IX(i + 1, j, k)]);\n"
"        wb = 0.5*(w[IX(i, j, k-1)] + w[IX(i+1, j, k-1)]);\n"
"        wf = 0.5*(w[IX(i, j, k)] + w[IX(i + 1, j, k)]);\n"
"\n"
"        // define the flow rate at the surface\n"
"        Fw = uw * Dy*Dz;\n"
"        Fe = ue * Dy*Dz;\n"
"        Fs = vs * Dx*Dz;\n"
"        Fn = vn * Dx*Dz;\n"
"        Fb = wb * Dx*Dy;\n"
"        Ff = wf * Dx*Dy;\n"
"\n"
"        // update the ap coefficient\n"
"        ap[IX(i,j,k)] = ap0[IX(i,j,k)] + ae[IX(i,j,k)] + aw[IX(i,j,k)]\n"
"                        + an[IX(i,j,k)]  + as[IX(i,j,k)] + af[IX(i,j,k)]\n"
"                        + ab[IX(i,j,k)] + Fe - Fw + Fn - Fs + Ff - Fb;\n"
"    } //end of FOR_U_CELL\n"
"\n"
"  } //end of U\n"
"  // V\n"
"  else if (var_type[0] == VY) {\n"
"    // FOR_V_CELL\n"
"    if (i>0 && i<imax+1 && j>0 && j<jmax && k>0 && k<kmax+1) {\n"
"        // define the dimensions\n"
"        dyn = gy[IX(i, j + 1, k)] - gy[IX(i, j, k)];\n"
"        dys = gy[IX(i, j, k)] - gy[IX(i, j - 1, k)];\n"
"        Dx = gx[IX(i, j, k)] - gx[IX(i - 1, j, k)];\n"
"        Dy = y[IX(i, j + 1, k)] - y[IX(i, j, k)];\n"
"        Dz = gz[IX(i, j, k)] - gz[IX(i, j, k - 1)];\n"
"\n"
"        // define the velocity at the surface\n"
"        uw = 0.5*(u[IX(i - 1, j, k)] + u[IX(i - 1, j + 1, k)]);\n"
"        ue = 0.5*(u[IX(i, j, k)] + u[IX(i, j + 1, k)]);\n"
"        vs = 0.5*(v[IX(i, j - 1, k)] + v[IX(i, j, k)]);\n"
"        vn = 0.5*(v[IX(i, j, k)] + v[IX(i, j + 1, k)]);\n"
"        wb = 0.5*(w[IX(i, j, k - 1)] + w[IX(i, j + 1, k - 1)]);\n"
"        wf = 0.5*(w[IX(i, j, k)] + w[IX(i, j +1, k)]);\n"
"\n"
"        // define the flow rate at the surface\n"
"        Fw = uw * Dy*Dz;\n"
"        Fe = ue * Dy*Dz;\n"
"        Fs = vs * Dx*Dz;\n"
"        Fn = vn * Dx*Dz;\n"
"        Fb = wb * Dx*Dy;\n"
"        Ff = wf * Dx*Dy;\n"
"\n"
"        // update the ap coefficient\n"
"        ap[IX(i,j,k)] = ap0[IX(i,j,k)] + ae[IX(i,j,k)] + aw[IX(i,j,k)]\n"
"                        + an[IX(i,j,k)]  + as[IX(i,j,k)] + af[IX(i,j,k)]\n"
"                        + ab[IX(i,j,k)] + Fe - Fw + Fn - Fs + Ff - Fb;\n"
"    } //end of FOR_V_CELL\n"
"  } //end of V\n"
"  // W\n"
"  if (var_type[0] == VZ) {\n"
"    // FOR_W_CELL\n"
"    if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax) {\n"
"        // define the dimensions\n"
"        dzf = gz[IX(i, j, k + 1)] - gz[IX(i, j, k)];\n"
"        dzb = gz[IX(i, j, k)] - gz[IX(i, j, k - 1)];\n"
"        Dx = gx[IX(i, j, k)] - gx[IX(i - 1, j, k)];\n"
"        Dy = gy[IX(i, j, k)] - gy[IX(i, j - 1, k)];\n"
"        Dz = z[IX(i, j, k + 1)] - z[IX(i, j, k)];\n"
"\n"
"        // define the velocity at the surface\n"
"        uw = 0.5*(u[IX(i - 1, j, k)] + u[IX(i - 1, j, k + 1)]);\n"
"        ue = 0.5*(u[IX(i, j, k)] + u[IX(i, j, k + 1)]);\n"
"        vs = 0.5*(v[IX(i, j - 1, k)] + v[IX(i, j - 1, k + 1)]);\n"
"        vn = 0.5*(v[IX(i, j, k)] + v[IX(i, j, k + 1)]);\n"
"        wb = 0.5*(w[IX(i, j, k - 1)] + w[IX(i, j, k)]);\n"
"        wf = 0.5*(w[IX(i, j, k)] + w[IX(i, j, k + 1)]);\n"
"\n"
"\n"
"        // define the flow rate at the surface\n"
"        Fw = uw * Dy*Dz;\n"
"        Fe = ue * Dy*Dz;\n"
"        Fs = vs * Dx*Dz;\n"
"        Fn = vn * Dx*Dz;\n"
"        Fb = wb * Dx*Dy;\n"
"        Ff = wf * Dx*Dy;\n"
"\n"
"        // update the ap coefficient\n"
"        ap[IX(i,j,k)] = ap0[IX(i,j,k)] + ae[IX(i,j,k)] + aw[IX(i,j,k)]\n"
"                        + an[IX(i,j,k)]  + as[IX(i,j,k)] + af[IX(i,j,k)]\n"
"                        + ab[IX(i,j,k)] + Fe - Fw + Fn - Fs + Ff - Fb;\n"
"    } //end of FOR_W_CELL\n"
"  } //end of W\n"
"  // T\n"
"  if (var_type[0] == TEMP){\n"
"      // FOR_ALL_CELL\n"
"    if (i>0 && i<imax+1 && j>0 && j<jmax+1 && k>0 && k<kmax+1) {\n"
"        // define the dimensions\n"
"        Dx = gx[IX(i, j, k)] - gx[IX(i - 1, j, k)];\n"
"        Dy = gy[IX(i, j, k)] - gy[IX(i, j - 1, k)];\n"
"        Dz = gz[IX(i, j, k)] - gz[IX(i, j, k - 1)];\n"
"\n"
"        // define the velocity at the surface\n"
"        uw = u[IX(i - 1, j, k)];\n"
"        ue = u[IX(i, j, k )];\n"
"        vs = v[IX(i, j - 1, k)];\n"
"        vn = v[IX(i, j, k)];\n"
"        wb = w[IX(i, j, k - 1)];\n"
"        wf = w[IX(i, j, k)];\n"
"\n"
"        // define the flow rate at the surface\n"
"        Fw = uw * Dy*Dz;\n"
"        Fe = ue * Dy*Dz;\n"
"        Fs = vs * Dx*Dz;\n"
"        Fn = vn * Dx*Dz;\n"
"        Fb = wb * Dx*Dy;\n"
"        Ff = wf * Dx*Dy;\n"
"\n"
"        // update the ap coefficient\n"
"        // change the demoninator by removing \"+ Fe - Fw + Fn - Fs + Ff - Fb;\"\n"
"        // this is to avoid the incorrect cacluation when the mass balance is not\n"
"        //  strictly met\n"
"        ap[IX(i,j,k)] = ap0[IX(i,j,k)] + ae[IX(i,j,k)] + aw[IX(i,j,k)]\n"
"                        + an[IX(i,j,k)]  + as[IX(i,j,k)] + af[IX(i,j,k)]\n"
"                        + ab[IX(i,j,k)];\n"
"    } //end of FOR_ALL_CELL\n"
"  } //end of T\n"
"\n"
"} //end of __kernel void ap_im_coeff\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// Kernel to adjust velocity\n"
"/// 7/1/2015\n"
"// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void adjust_velocity(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX) {\n"
"  int i, j, k;\n"
"  int it = get_global_id(0);;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int index= para->geom.index;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"   __global REAL *u = &var[VX*size], *v = &var[VY*size], *w = &var[VZ*size];\n"
"  REAL dvel;\n"
"   __global REAL *flagp = &var[FLAGP*size];\n"
"\n"
"  dvel = para->bc_simp.mass_corr;\n"
"\n"
"  /*---------------------------------------------------------------------------\n"
"  | Adjust the outflow\n"
"  ---------------------------------------------------------------------------*/\n"
"    i = BINDEX[0*size+it];\n"
"    j = BINDEX[1*size+it];\n"
"    k = BINDEX[2*size+it];\n"
"\n"
"    if(flagp[IX(i,j,k)]==2) {\n"
"      if(i==0) u[IX(i,j,k)] -= dvel;\n"
"      if(i==imax+1) u[IX(i-1,j,k)]+= dvel;\n"
"      if(j==0) v[IX(i,j,k)] -= dvel;\n"
"      if(j==jmax+1) v[IX(i,j-1,k)] += dvel;\n"
"      if(k==0) w[IX(i,j,k)] -= dvel;\n"
"      if(k==kmax+1) w[IX(i,j,k-1)] += dvel;\n"
"    }\n"
"} // End of mass_conservation()\n"
"\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// Kernel to set the force mass balance\n"
"/// Use only one core\n"
"/// 7/1/2015\n"
"// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void mass_conservation(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX) {\n"
"  int i, j, k;\n"
"  int it;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int index= para->geom.index;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"   __global REAL *u = &var[VX*size], *v = &var[VY*size], *w = &var[VZ*size];\n"
"  REAL mass_in = (REAL) 0.0, mass_out = (REAL) 0.00000001;\n"
"  REAL area_out=0;\n"
"   __global REAL *flagp = &var[FLAGP*size];\n"
"  REAL axy, ayz, azx;\n"
"\n"
"  // Go through all the inlets and outlets\n"
"  for(it=0; it<index; it++) {\n"
"    i = BINDEX[0*size+it];\n"
"    j = BINDEX[1*size+it];\n"
"    k = BINDEX[2*size+it];\n"
"\n"
"    axy = area_xy(para, var, &i, &j, &k);\n"
"    ayz = area_yz(para, var, &i, &j, &k);\n"
"    azx = area_zx(para, var, &i, &j, &k);\n"
"    /*-------------------------------------------------------------------------\n"
"    | Compute the total inflow\n"
"    -------------------------------------------------------------------------*/\n"
"    if(flagp[IX(i,j,k)]==0) {\n"
"      // West\n"
"      if(i==0) mass_in += u[IX(i,j,k)] * ayz;\n"
"      // East\n"
"      if(i==imax+1) mass_in += (-u[IX(i,j,k)]) * ayz;\n"
"      // South\n"
"      if(j==0) mass_in += v[IX(i,j,k)] * azx;\n"
"      // North\n"
"      if(j==jmax+1) mass_in += (-v[IX(i,j,k)]) * azx;\n"
"      // Floor\n"
"      if(k==0) mass_in += w[IX(i,j,k)] * axy;\n"
"      // Ceiling\n"
"      if(k==kmax+1) mass_in += (-w[IX(i,j,k)]) * axy;\n"
"    }\n"
"    /*-------------------------------------------------------------------------\n"
"    | Compute the total outflow\n"
"    -------------------------------------------------------------------------*/\n"
"    if(flagp[IX(i,j,k)]==2) {\n"
"      // West\n"
"      if(i==0) {\n"
"        mass_out += (-u[IX(i,j,k)]) * ayz;\n"
"        area_out +=  ayz;\n"
"      }\n"
"      // East\n"
"      if(i==imax+1) {\n"
"        mass_out += u[IX(i-1,j,k)] * ayz;\n"
"        area_out += ayz;\n"
"      }\n"
"      // South\n"
"      if(j==0) {\n"
"        mass_out += (-v[IX(i,j,k)]) * azx;\n"
"        area_out += azx;\n"
"      }\n"
"      // North\n"
"      if(j==jmax+1) {\n"
"        mass_out += v[IX(i,j-1,k)] * azx;\n"
"        area_out += azx;\n"
"      }\n"
"      // Floor\n"
"      if(k==0) {\n"
"        mass_out += (-w[IX(i,j,k)]) * axy;\n"
"        area_out += axy;\n"
"      }\n"
"      // Ceiling\n"
"      if(k==kmax+1) {\n"
"        mass_out += w[IX(i,j,k-1)] * axy;\n"
"        area_out += axy;\n"
"      }\n"
"    } // End of computing outflow\n"
"  } // End of for loop for going through all the inlets and outlets\n"
"\n"
"  /*---------------------------------------------------------------------------\n"
"  | Return the adjusted velocity for mass conservation\n"
"  ---------------------------------------------------------------------------*/\n"
"  para->bc_simp.mass_corr = (mass_in-mass_out)/area_out;\n"
"\n"
"  //printf(\"the velocity correction is %f \",para->bc_simp.mass_corr );\n"
"} // End of adjust_velocity()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// Kernel to reset average data\n"
"/// 8/9/2015\n"
"// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void reset_time_averaged_data(__global PARA_DATA_SIMP *para, __global REAL *var) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int it;\n"
"  int step = para->mytime.step_mean;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int index= para->geom.index;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"   __global REAL *u = &var[VX*size], *v = &var[VY*size], *w = &var[VZ*size], *T = &var[TEMP*size];\n"
"   __global REAL *um = &var[VXM*size], *vm = &var[VYM*size], *wm = &var[VZM*size], *Tm = &var[TEMPM*size];\n"
"\n"
"   step = 0;\n"
"   um[IX(i,j,k)] = 0;\n"
"   vm[IX(i,j,k)] = 0;\n"
"   wm[IX(i,j,k)] = 0;\n"
"   Tm[IX(i,j,k)] = 0;\n"
"\n"
"} //end of reset_time_averaged_data()\n"
"\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// Kernel to average data\n"
"/// 8/9/2015\n"
"// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void add_time_averaged_data(__global PARA_DATA_SIMP *para, __global REAL *var) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int it;\n"
"  int step = para->mytime.step_mean;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int index= para->geom.index;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"   __global REAL *u = &var[VX*size], *v = &var[VY*size], *w = &var[VZ*size], *T = &var[TEMP*size];\n"
"   __global REAL *um = &var[VXM*size], *vm = &var[VYM*size], *wm = &var[VZM*size], *Tm = &var[TEMPM*size];\n"
"\n"
"   um[IX(i,j,k)] = um[IX(i,j,k)] + u[IX(i,j,k)];\n"
"   vm[IX(i,j,k)] = vm[IX(i,j,k)] + v[IX(i,j,k)];\n"
"   wm[IX(i,j,k)] = wm[IX(i,j,k)] + w[IX(i,j,k)];\n"
"   Tm[IX(i,j,k)] = Tm[IX(i,j,k)] + T[IX(i,j,k)];\n"
"   para->mytime.step_mean = para->mytime.step_mean +1;\n"
"} //end of add_time_averaged_data()\n"
"\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"/// Kernel to average data (void, not used at the moment)\n"
"/// 8/9/2015\n"
"// Wei Tian\n"
"///////////////////////////////////////////////////////////////////////////////\n"
"__kernel void time_averaged(__global PARA_DATA_SIMP *para, __global REAL *var) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int step = para->mytime.step_mean;\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int index= para->geom.index;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"   __global REAL *u = &var[VX*size], *v = &var[VY*size], *w = &var[VZ*size], *T = &var[TEMP*size];\n"
"   __global REAL *um = &var[VXM*size], *vm = &var[VYM*size], *wm = &var[VZM*size], *Tm = &var[TEMPM*size];\n"
"\n"
"   um[IX(i,j,k)] = um[IX(i,j,k)]/para->mytime.step_mean;\n"
"   vm[IX(i,j,k)] = vm[IX(i,j,k)]/para->mytime.step_mean;\n"
"   wm[IX(i,j,k)] = wm[IX(i,j,k)]/para->mytime.step_mean;\n"
"   Tm[IX(i,j,k)] = Tm[IX(i,j,k)]/para->mytime.step_mean;\n"
"   printf(\"the step is %d \", para->mytime.step_mean);\n"
"} //end of time_averaged()\n"
"\n"
"__kernel void chen_min_distance(__global PARA_DATA_SIMP *para, __global REAL *var, __global int *BINDEX, __global int*START, __global int*END) {\n"
"  int i = get_global_id(0);\n"
"  int j = get_global_id(1);\n"
"  int k = get_global_id(2);\n"
"  int imax = para->geom.imax, jmax = para->geom.jmax;\n"
"  int kmax = para->geom.kmax;\n"
"  int index= para->geom.index;\n"
"  int IMAX = imax+2, IJMAX = (imax+2)*(jmax+2);\n"
"  int size=(imax+2)*(jmax+2)*(kmax+2);\n"
"  __global REAL *flagp = &var[FLAGP*size];\n"
"  __global REAL *x = &var[X*size];\n"
"  __global REAL *y = &var[Y*size];\n"
"  __global REAL *z = &var[Z*size];\n"
"  __global REAL *tmp = &var[TMP1*size];\n"
"  int it,i_bc,j_bc,k_bc;\n"
"  REAL length,lx,ly,lz;\n"
"  \n"
"  if (flagp[IX(i,j,k)]<0){\n"
"	for (it=START[0];it<END[0];it++){\n"
"	  i_bc = BINDEX[0*size+it];\n"
"	  j_bc = BINDEX[1*size+it];\n"
"	  k_bc = BINDEX[2*size+it];\n"
"	  lx = fabs(x[IX(i,j,k)]-x[IX(i_bc,j_bc,k_bc)]);\n"
"	  ly = fabs(y[IX(i,j,k)]-y[IX(i_bc,j_bc,k_bc)]);\n"
"	  lz = fabs(z[IX(i,j,k)]-z[IX(i_bc,j_bc,k_bc)]);\n"
"	  length = sqrt(lx*lx+ly*ly+lz*lz);\n"
"	  if (length<tmp[IX(i,j,k)]){ \n"
"	    tmp[IX(i,j,k)] = length;\n"
"	  }\n"
"	}\n"
"	var[MIN_DISTANCE*size+IX(i,j,k)] = tmp[IX(i,j,k)];\n"
"	//printf (\"TMP is %f \",tmp[IX(i,j,k)]);\n"
"	//printf (\"MIN_DISTANCE is %f \",var[MIN_DISTANCE*size+IX(i,j,k)]);\n"
"  }\n"
"  barrier(CLK_GLOBAL_MEM_FENCE );\n"
"} //end of chen_min_distance()\n"
;
